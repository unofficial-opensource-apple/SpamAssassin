#!/usr/bin/perl -w -T
# <@LICENSE>
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at:
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# </@LICENSE>

my $PREFIX          = '@@PREFIX@@';             # substituted at 'make' time
my $DEF_RULES_DIR   = '@@DEF_RULES_DIR@@';      # substituted at 'make' time
my $LOCAL_RULES_DIR = '@@LOCAL_RULES_DIR@@';    # substituted at 'make' time
my $LOCAL_STATE_DIR = '@@LOCAL_STATE_DIR@@';    # substituted at 'make' time
use lib '@@INSTALLSITELIB@@';                   # substituted at 'make' time

# added by jm for use inside the distro
# This is disabled during the "make install" process.
BEGIN {
  if ( -e '../blib/lib/Mail/SpamAssassin.pm' ) {    # REMOVEFORINST
    unshift ( @INC, '../blib/lib' );                # REMOVEFORINST
  } else {                                          # REMOVEFORINST
    unshift ( @INC, '../lib' );                     # REMOVEFORINST
  }                                                 # REMOVEFORINST
}

use strict;
use warnings;

# Big Ugly Hack; purpose: don't force requirement on IO::Socket::INET6
BEGIN {
  use Socket;
  eval {
    require IO::Socket::INET6;
    require Socket6;
  };
  if ($@) {    # IPv4 only
    require IO::Socket::INET;
    *new_io_socket_inetx = sub { IO::Socket::INET->new(@_); };
    *ip_or_name_to_ip    = sub {
      my $in_addr = (gethostbyname(shift))[4] or return undef;
      Socket::inet_ntoa($in_addr);
    };
    *peer_info_from_socket = sub {
      my $sock = shift;
      my ($port, $in_addr) = Socket::sockaddr_in($sock->peername)
        or return;
      my $addr = Socket::inet_ntoa($in_addr) or return;
      my $host = gethostbyaddr($in_addr, Socket::AF_INET()) || $addr;
      return ($port, $addr, $host);
    };
  }
  else {    # IPv4+IPv6
    *new_io_socket_inetx = sub { IO::Socket::INET6->new(@_); };
    *ip_or_name_to_ip    = sub {
      my $addr = (
        Socket6::getaddrinfo(
          shift, '', Socket::AF_UNSPEC(), Socket::SOCK_STREAM()
        )
        )[3]
        or return undef;
      $addr = (Socket6::getnameinfo($addr, Socket6::NI_NUMERICHOST()))[0];
    };
    *peer_info_from_socket = sub {
      my $sock = shift;
      my $addr = $sock->peerhost or return;
      my $host =
        (Socket6::getnameinfo($sock->peername, Socket6::NI_NAMEREQD()))[0]
        || $addr;
      return ($sock->peerport(), $addr, $host);
    };
  }
}

use IO::Handle;
use IO::Pipe;

use Mail::SpamAssassin;
use Mail::SpamAssassin::NetSet;
use Mail::SpamAssassin::SubProcBackChannel;
use Mail::SpamAssassin::SpamdForkScaling qw(:pfstates);
use Mail::SpamAssassin::Logger qw(:DEFAULT log_message);
use Mail::SpamAssassin::Timeout;

use Getopt::Long;
use Pod::Usage;
use POSIX qw(:sys_wait_h);
use POSIX qw(setsid sigprocmask _exit);
use Errno;

use Cwd ();
use File::Spec 0.8;
use File::Path;
use Carp ();

# Check to make sure the script version and the module version matches.
# If not, die here!  Also, deal with unchanged VERSION macro.
if ($Mail::SpamAssassin::VERSION ne '@@VERSION@@' && '@@VERSION@@' ne "\@\@VERSION\@\@") {
  die 'spamd: spamd script is v@@VERSION@@, but using modules v'.$Mail::SpamAssassin::VERSION."\n";
}

# Load Time::HiRes if it's available
BEGIN {
  eval { require Time::HiRes };
  Time::HiRes->import(qw(time)) unless $@;
  # redirect __WARN__ and __DIE__
  # do not trap warnings here based on eval scope; evals are very
  # common throughout.  die()s can be trapped though.
  $SIG{__WARN__} = sub {
    log_message("warn", $_[0]);
  };
  $SIG{__DIE__} = sub {
    # see http://use.perl.org/comments.pl?mode=flat&sid=33872 for $^S
    log_message("error", $_[0]) unless $^S;
  };
}

my %resphash = (
  EX_OK          => 0,     # no problems
  EX_USAGE       => 64,    # command line usage error
  EX_DATAERR     => 65,    # data format error
  EX_NOINPUT     => 66,    # cannot open input
  EX_NOUSER      => 67,    # addressee unknown
  EX_NOHOST      => 68,    # host name unknown
  EX_UNAVAILABLE => 69,    # service unavailable
  EX_SOFTWARE    => 70,    # internal software error
  EX_OSERR       => 71,    # system error (e.g., can't fork)
  EX_OSFILE      => 72,    # critical OS file missing
  EX_CANTCREAT   => 73,    # can't create (user) output file
  EX_IOERR       => 74,    # input/output error
  EX_TEMPFAIL    => 75,    # temp failure; user is invited to retry
  EX_PROTOCOL    => 76,    # remote error in protocol
  EX_NOPERM      => 77,    # permission denied
  EX_CONFIG      => 78,    # configuration error
  EX_TIMEOUT     => 79,    # read timeout
);

sub print_version {
  printf("%s version %s\n", "SpamAssassin Server", Mail::SpamAssassin::Version());
  printf("  running on Perl %s\n", join(".", map { $_||=0; $_*1 } ($] =~ /(\d)\.(\d{3})(\d{3})?/)));
  eval { require IO::Socket::SSL; };
  printf("  with SSL support (%s %s)\n", "IO::Socket::SSL", $IO::Socket::SSL::VERSION) unless ($@);
  eval { require Compress::Zlib; };
  printf("  with zlib support (%s %s)\n", "Compress::Zlib", $Compress::Zlib::VERSION) unless ($@);
}

sub print_usage_and_exit {
  my ( $message, $respnam ) = (@_);
  $respnam ||= 'EX_USAGE';

  if ($respnam eq 'EX_OK' ) {
    print_version();
    print("\n");
  }
  pod2usage(
    -verbose => 0,
    -message => $message,
    -exitval => $resphash{$respnam},
  );
}

# defaults
my %opt = (
  'user-config'   => 1,
  'ident-timeout' => 5.0,
  # scaling settings; some of these aren't actually settable via cmdline
  'server-scale-period' => 2,   # how often to scale the # of kids, secs
  'min-children'  => 1,         # min kids to have running
  'min-spare'     => 1,         # min kids that must be spare
  'max-spare'     => 2,         # max kids that should be spare
  'cf'            => [],        # extra config lines
);


# bug 1725, 2192:
# Untaint all command-line options and ENV vars, since spamd is launched
# as a daemon from a known-safe environment. Also store away some of the
# vars we need for a SIGHUP later on.

# Testing for taintedness only works before detainting %ENV
Mail::SpamAssassin::Util::am_running_in_taint_mode();

# First clean PATH and untaint the environment -- need to do this before
# Cwd::cwd(), else it will croak.
Mail::SpamAssassin::Util::clean_path_in_taint_mode();
Mail::SpamAssassin::Util::untaint_var( \%ENV );

# The zeroth argument will be replaced in daemonize().
my $ORIG_ARG0 = Mail::SpamAssassin::Util::untaint_var($0);

# Getopt::Long clears all arguments it processed (untaint both @ARGVs here!)
my @ORIG_ARGV = Mail::SpamAssassin::Util::untaint_var( \@ARGV );

# daemonize() switches to the root later on and we need to come back here
# somehow -- untaint the dir to be on the safe side.
my $ORIG_CWD = Mail::SpamAssassin::Util::untaint_var( Cwd::cwd() );

# Parse the command line
Getopt::Long::Configure("bundling");
GetOptions(
  'allow-tell'               => \$opt{'tell'},
  'allowed-ips|A=s'          => \@{ $opt{'allowed-ip'} },
  'auth-ident'               => \$opt{'auth-ident'},
  'configpath|C=s'           => \$opt{'configpath'},
  'c'                        => \$opt{'create-prefs'},
  'create-prefs!'            => \$opt{'create-prefs'},
  'daemonize!'               => \$opt{'daemonize'},
  'debug|D:s'                => \$opt{'debug'},
  'd'                        => \$opt{'daemonize'},
  'groupname|g=s'            => \$opt{'groupname'},
  'helper-home-dir|H:s'      => \$opt{'home_dir_for_helpers'},
  'help|h'                   => \$opt{'help'},
  'ident-timeout=f'          => \$opt{'ident-timeout'},
  'ipv4only|ipv4-only|ipv4'  => \$opt{'force_ipv4'},
  'ldap-config!'             => \$opt{'ldap-config'},
  'listen-ip|ip-address|i:s' => \$opt{'listen-ip'},
  'local!'                   => \$opt{'local'},
  'L'                        => \$opt{'local'},
  'l'                        => \$opt{'tell'},
  'round-robin!'             => \$opt{'round-robin'},
  'min-children=i'           => \$opt{'min-children'},
  'max-children|m=i'         => \$opt{'max-children'},
  'min-spare=i'              => \$opt{'min-spare'},
  'max-spare=i'              => \$opt{'max-spare'},
  'max-conn-per-child=i'     => \$opt{'max-conn-per-child'},
  'nouser-config|x'          => sub { $opt{'user-config'} = 0 },
  'paranoid!'                => \$opt{'paranoid'},
  'P'                        => \$opt{'paranoid'},
  'pidfile|r=s'              => \$opt{'pidfile'},
  'port|p=s'                 => \$opt{'port'},
  'Q'                        => \$opt{'setuid-with-sql'},
  'q'                        => \$opt{'sql-config'},
  'server-cert=s'            => \$opt{'server-cert'},
  'server-key=s'             => \$opt{'server-key'},
  'setuid-with-ldap'         => \$opt{'setuid-with-ldap'},
  'setuid-with-sql'          => \$opt{'setuid-with-sql'},
  'siteconfigpath=s'         => \$opt{'siteconfigpath'},
  'cf=s'                     => \@{$opt{'cf'}},
  'socketgroup=s'            => \$opt{'socketgroup'},
  'socketmode=s'             => \$opt{'socketmode'},
  'socketowner=s'            => \$opt{'socketowner'},
  'socketpath=s'             => \$opt{'socketpath'},
  'sql-config!'              => \$opt{'sql-config'},
  'ssl'                      => \$opt{'ssl'},
  'ssl-port=s'               => \$opt{'ssl-port'},
  'ssl-version=s'            => \$opt{'ssl-version'},
  'syslog-socket=s'          => \$opt{'syslog-socket'},
  'syslog|s=s'               => \$opt{'syslog'},
  'timeout-tcp|T=i'          => \$opt{'timeout-tcp'},
  'timeout-child|t=i'        => \$opt{'timeout-child'},
  'user-config'              => \$opt{'user-config'},
  'username|u=s'             => \$opt{'username'},
  'version|V'                => \$opt{'version'},
  'virtual-config-dir=s'     => \$opt{'virtual-config-dir'},
  'v'                        => \$opt{'vpopmail'},
  'vpopmail!'                => \$opt{'vpopmail'},

  #
  # NOTE: These are old options.  We should ignore (but warn about)
  # the ones that are now defaults.  Everything else gets a die (see note2)
  # so the user doesn't get us doing something they didn't expect.
  #
  # NOTE2: 'die' doesn't actually stop the process, GetOptions() catches
  # it, then passes the error on, so we'll end up doing a Usage statement.
  # You can avoid that by doing an explicit exit in the sub.
  #
  
  # last in 2.3
  'F:i'                   => sub { warn "spamd: the -F option has been removed from spamd, please remove from your commandline and re-run\n"; exit 2; },
  'add-from!'             => sub { warn "spamd: the --add-from option has been removed from spamd, please remove from your commandline and re-run\n"; exit 2; },

  # last in 2.4
  'stop-at-threshold|S' => sub { warn "spamd: the -S option has been deprecated and is no longer supported, ignoring\n" },

) or print_usage_and_exit();

if ($opt{'help'}) {
  print_usage_and_exit(qq{For more details, use "man spamd".\n}, 'EX_OK');
}
if ($opt{'version'}) {
  print_version();
  exit($resphash{'EX_OK'});
}


# Enable debugging, if any areas were specified.  We do this already here,
# accessing some non-public API so we can use the convenient dbg() routine.
# Don't do this at home (aka any 3rd party tools), kids!
if (defined $opt{'debug'}) {
  $opt{'debug'} ||= 'all';
}
# always turn on at least info-level debugging for spamd
$opt{'debug'} ||= 'info';
# turn on debugging facilities as soon as possible
Mail::SpamAssassin::Logger::add_facilities($opt{'debug'});

# bug 2228: make the values of (almost) all parameters which accept file paths
# absolute, so they are still valid after daemonize()
foreach my $opt (
  qw(
  configpath
  siteconfigpath
  socketpath
  pidfile
  home_dir_for_helpers
  )
  )
{
  $opt{$opt} = Mail::SpamAssassin::Util::untaint_file_path(
    File::Spec->rel2abs( $opt{$opt} )    # rel2abs taints the new value!
  ) if ( $opt{$opt} );
}

# sanity checking on parameters: if --socketpath is used, and --port or
# --ssl-port is NOT specified, it means that we're using UNIX domain sockets,
# none of the IP params are allowed. The code would probably work ok if we
# didn't check it, but it's better if we detect the error and report it lest
# the admin find surprises.

my $listen_unix = 1;
my $listen_inet = 1;
my $listen_ssl  = 0;
if (!defined $opt{'socketpath'}) {
  $listen_unix = 0;
} else {
  $listen_inet = 0;
}

if (
  ( @{ $opt{'allowed-ip'} } > 0 )
    or defined $opt{'auth-ident'}
    or defined $opt{'port'}
  )
{
  $listen_inet = 1;
}

if (
    defined $opt{'ssl'}
    or defined $opt{'ssl-port'}
    or defined $opt{'ssl-version'}
  )
{
  $listen_ssl = 1;
  if (!defined $opt{'ssl-port'}) {
    $listen_inet = 0;
  }
}

if (
  !$opt{'socketpath'}
  and ( $opt{'socketowner'}
    or $opt{'socketgroup'}
    or $opt{'socketmode'})
  )
{
  print_usage_and_exit("ERROR: --socketowner/group/mode requires --socketpath param");
}

# These can be changed on command line with -A flag
# but only if we're not using UNIX domain sockets
my $allowed_nets = Mail::SpamAssassin::NetSet->new();
if ( not defined $opt{'socketpath'} ) {
  if ( @{ $opt{'allowed-ip'} } ) {
    set_allowed_ip( grep length, map { split /,/ } @{ $opt{'allowed-ip'} } );
  }
  else {
    set_allowed_ip('127.0.0.1'); #, '::1'); M::SA::NetSet needs fixing for IPv6
  }
}

# ident-based spamc user authentication
if ( $opt{'auth-ident'} ) {
  eval { require Net::Ident };
  die "spamd: ident-based authentication requested, but Net::Ident is unavailable ($@)\n"
    if ($@);

  $opt{'ident-timeout'} = undef if $opt{'ident-timeout'} <= 0.0;
  import Net::Ident qw(ident_lookup);
}

# Check for server certs
$opt{'server-key'}  ||= "$LOCAL_RULES_DIR/certs/server-key.pem";
$opt{'server-cert'} ||= "$LOCAL_RULES_DIR/certs/server-cert.pem";
if ( $listen_ssl ) {
  eval { require IO::Socket::SSL };
  die "spamd: SSL encryption requested, but IO::Socket::SSL is unavailable ($@)\n"
    if ($@);

  if ( !-e $opt{'server-key'} ) {
    die "spamd: server key file $opt{'server-key'} does not exist\n";
  }
  if ( !-e $opt{'server-cert'} ) {
    die "spamd: server certificate file $opt{'server-cert'} does not exist\n";
  }
}

### Begin initialization of logging ########################

# The syslog facility can be changed on the command line with the
# --syslog flag. Special cases are:
# * A log facility of 'stderr' will log to STDERR
# * " "   "        "  'null' disables all logging
# * " "   "        "  'file' logs to the file "spamd.log"
# * Any facility containing non-word characters is interpreted as the name
#   of a specific logfile
my $log_facility = $opt{'syslog'} || 'mail';

# The socket to log over can be changed on the command line with the
# --syslog-socket flag. Logging to any file handler (either a specific log
# file or STDERR) is internally represented by a socket 'file', no logging
# at all is 'none'. The latter is different from --syslog-socket=none which
# gets mapped to --syslog=stderr and such --syslog-socket=file. An internal
# socket of 'none' means as much as --syslog=null. Sounds complicated? It is.
# But it works.
my $log_socket = lc($opt{'syslog-socket'}) || 'unix';

# This is the default log file; it can be changed on the command line
# via a --syslog flag containing non-word characters.
my $log_file = "spamd.log";

# A specific log file was given (--syslog=/path/to/file).
if ($log_facility =~ /[^a-z0-9]/) {
  $log_file = $log_facility;
  $log_socket = 'file';
}
# The generic log file was requested (--syslog=file).
elsif (lc($log_facility) eq 'file') {
  $log_socket = 'file';
}
# The casing is kept only if the facility specified a file.
else {
  $log_facility = lc($log_facility);
}

# Either above or at the command line the socket was set
# to 'file' (--syslog-socket=file).
if ($log_socket eq 'file') {
  $log_facility = 'file';
}
# The socket 'none' (--syslog-socket=none) historically
# represents logging to STDERR.
elsif ($log_socket eq 'none') {
  $log_facility = 'stderr';
}

# Either above or at the command line the facility was set
# to 'stderr' (--syslog=stderr).
if ($log_facility eq 'stderr') {
  $log_socket = 'file';
}

# Logging via syslog is requested.
if ($log_socket ne 'file' && $log_facility ne 'null') {
  if (!Mail::SpamAssassin::Logger::add(method => 'syslog',
				       socket => $log_socket,
				       facility => $log_facility,
                                       ident => 'spamd'))
  {
    # syslog method failed 
    $log_facility = 'stderr';
  }
}
# Otherwise, the user wants to log to some file.
elsif ($log_facility eq 'file') {
  if (!Mail::SpamAssassin::Logger::add(method => 'file',
				       filename => $log_file))
  {
    # file method failed
    $log_facility = 'stderr';
  }
}

### End initialization of logging ##########################

# REIMPLEMENT: if $log_socket is none, fall back to log_facility 'stderr'.
# If log_fac is stderr and defined $opt{'debug'}, set log_fac to 'null' to
# avoid duplicating log messages.
# TVD: isn't this already done up above?

# support setuid() to user unless:
# run with -u
# we're not root
# doing --vpopmail or --virtual-config-dir
# we disable user-config
my $setuid_to_user = (
	$opt{'username'} ||
	$> != 0 ||
	$opt{'vpopmail'} ||
	$opt{'virtual-config-dir'}
      ) ? 0 : 1;

dbg("spamd: will perform setuids? $setuid_to_user");

if ( $opt{'vpopmail'} ) {
  if ( !$opt{'username'} ) {
    die "spamd: cannot use --vpopmail without -u\n";
  }
}

if ( $opt{'virtual-config-dir'} ) {
  if ( !$opt{'username'} ) {
    die "spamd: cannot use --virtual-config-dir without -u\n";
  }
}

# always copy the config, later code may disable
my $copy_config_p = 1;

my $current_user;

my $client;               # used for the client connection ...
my $childlimit;           # max number of kids allowed
my $timeout_tcp;          # socket timeout (connect->headers), 0=no timeout
my $timeout_child;        # processing timeout (headers->finish), 0=no timeout
my $clients_per_child;    # number of clients each child should process
my %children = ();        # current children

if ( defined $opt{'max-children'} ) {
  $childlimit = $opt{'max-children'};

  # Make sure that the values are at least 1
  $childlimit = undef if ( $childlimit < 1 );
}

if ( defined $opt{'max-conn-per-child'} ) {
  $clients_per_child = $opt{'max-conn-per-child'};

  # Make sure that the values are at least 1
  $clients_per_child = undef if ( $clients_per_child < 1 );
}

if (defined $opt{'timeout-tcp'}) {
  $timeout_tcp = $opt{'timeout-tcp'};
  $timeout_tcp = undef if ($timeout_tcp < 1);
}

if (defined $opt{'timeout-child'}) {
  $timeout_child = $opt{'timeout-child'};
  $timeout_child = undef if ($timeout_child < 1);
}

# Set some "sane" limits for defaults
$childlimit        ||= 5;
$clients_per_child ||= 200;
$timeout_child     ||= 300;
$timeout_tcp       ||= 30;

# ensure scaling parameters are logical
if ($opt{'min-children'} < 1) {
  $opt{'min-children'} = 1;
}
if ($opt{'min-spare'} < 0) {
  $opt{'min-spare'} = 0;
}
if ($opt{'min-spare'} > $childlimit) {
  $opt{'min-spare'} = $childlimit-1;
}
if ($opt{'max-spare'} < $opt{'min-spare'}) {
  # emulate Apache behaviour:
  # http://httpd.apache.org/docs-2.0/mod/prefork.html#maxspareservers
  $opt{'max-spare'} = $opt{'min-spare'}+1;
}

my $dontcopy = 1;
if ( $opt{'create-prefs'} ) { $dontcopy = 0; }

my $orighome;
if ( defined $ENV{'HOME'} ) {
  if ( defined $opt{'username'} )
  {    # spamd is going to run as another user, so reset $HOME
    if ( my $nh = ( getpwnam( $opt{'username'} ) )[7] ) {
      $ENV{'HOME'} = $nh;
    }
    else {
      die "spamd: unable to determine home directory for user '"
        . $opt{'username'} . "'\n";
    }
  }

  $orighome = $ENV{'HOME'};    # keep a copy for use by Razor, Pyzor etc.
  delete $ENV{'HOME'};         # we do not want to use this when running spamd
}

# Do whitelist later in tmp dir. Side effect: this will be done as -u user.

my ( $sslport, $sslversion, $inetport, $addr, $proto );

if ( $listen_inet || $listen_ssl ) {
  $proto = getprotobyname('tcp') or die "getprotobyname(tcp): $!";

  $addr = $opt{'listen-ip'};
  if (defined $addr) {
    if ($addr ne '') {
      $addr = ip_or_name_to_ip($addr);
      die "spamd: invalid address: $opt{'listen-ip'}\n" unless $addr;
    }
    else {
      $addr = '0.0.0.0';    # FIXME: this won't bind to IPv6 sockets
    }
  }
  else {
    $addr = '127.0.0.1';
  }
}

my $backchannel = Mail::SpamAssassin::SubProcBackChannel->new();
my $scaling;
if (!$opt{'round-robin'})
{
  my $max_children = $childlimit;

  # change $childlimit to avoid churn when we startup and create loads
  # of spare servers; when we're using scaling, it's not as important
  # as it was with the old algorithm.
  if ($childlimit > $opt{'max-spare'}) {
    $childlimit = $opt{'max-spare'};
  }

  $scaling = Mail::SpamAssassin::SpamdForkScaling->new({
        backchannel => $backchannel,
        min_children => $opt{'min-children'},
        max_children => $max_children,
        min_idle => $opt{'min-spare'},
        max_idle => $opt{'max-spare'},
        cur_children_ref => \$childlimit
      });
}

# ---------------------------------------------------------------------------

my $listeninfo = compose_listen_info_string();

sub compose_listen_info_string {
  my @listeninfo = ();

  if ( $listen_unix ) {
    push @listeninfo, "UNIX domain socket " . $opt{'socketpath'};
  }

  if ( $listen_ssl ) {
    $sslport = $opt{'ssl-port'} || $opt{'port'} || 783;
    if ($sslport !~ /^(\d+)$/ ) {
      $sslport = ( getservbyname($sslport, 'tcp') )[2];
      die "spamd: invalid ssl-port: $opt{'port'}\n" unless $sslport;
    }
    $sslversion = $opt{'ssl-version'} || 'sslv23';
    if ($sslversion !~ /^(?:sslv([23]|23)|(tlsv1))$/) {
      die "spamd: invalid ssl-version: $opt{'ssl-version'}\n";
    }

    push @listeninfo, "SSL port $sslport/tcp";
    push @listeninfo, "SSL version $sslversion";
  }

  if ( $listen_inet ) {
    $inetport = $opt{'port'} || 783;
    if ($inetport !~ /^(\d+)$/ ) {
      $inetport = ( getservbyname($inetport, 'tcp') )[2];
      die "spamd: invalid port: $opt{'port'}\n" unless $inetport;
    }

    push @listeninfo, "port $inetport/tcp";
  }

  # just for reporting at startup
  $listeninfo = join ', ', @listeninfo;
}

# ---------------------------------------------------------------------------
# Server (listening) socket setup for the various supported types

my ( $server_inet, $server_unix, $server_ssl );
my ( $fd_inet, $fd_unix, $fd_ssl );
my $have_multiple_server_socks;
my $server_select_mask;

# abstract out the setup-retry code
if ( $listen_unix ) {
  server_sock_setup(sub { server_sock_setup_unix(); });
}
if ( $listen_ssl ) {
  server_sock_setup(sub { server_sock_setup_ssl(); });
}
if ( $listen_inet ) {
  server_sock_setup(sub { server_sock_setup_inet(); });
}

sub server_sock_setup {
  my $sub = shift;

  # retry 3 times to bind to the listening socket; 3 seconds delay,
  # max, but should allow a little time for any existing shutting-down
  # server to complete shutdown
  for my $retry (1 .. 3) {
    if ($retry > 1) { sleep 1; }

    eval { $sub->(); };
    last unless ($@);       # success => break

    if ($retry == 3) {
      die $@;               # this is fatal
    } else {
      warn "server socket setup failed, retry $retry: $@";
      # but retry
    }
  }
}

# ---------------------------------------------------------------------------

# Create the sockets
sub server_sock_setup_unix {
  my $path = $opt{'socketpath'};

  # see if the socket is in use: if we connect to the current socket, it
  # means that spamd is already running, so we have to bail on our own.
  # Yes, there is a window here: best we can do for now. There is almost
  # certainly a better way, but we don't know it. Yet.

  if (-e $path) {
    unless (-S $path) {
      die "spamd: file $path exists but is no socket, exiting\n";
    }
  
    if ( new IO::Socket::UNIX( Peer => $path, Type => SOCK_STREAM ) ) {
      # we connected successfully: must alreadybe running

      undef $opt{'socketpath'};    # so exit handlers won't unlink it!

      die "spamd: already running on $path, exiting\n";
    }
    else {
      dbg("spamd: removing stale socket file $path");
      unlink $path;
    }
  }
  if (not -d (File::Spec->splitpath($path))[1]) {
    die "spamd: directory for $path does not exist, exiting\n";
  }

  my %socket = (
    Local  => $path,
    Type   => SOCK_STREAM,
    Listen => SOMAXCONN,
  );
  dbg("spamd: creating UNIX socket:\n" . join("\n", map { " $_: " . (defined $socket{$_} ? $socket{$_} : "(undef)") } sort keys %socket));
  $server_unix = IO::Socket::UNIX->new(%socket);
  
  # sanity check!  cf. bug 3490
  if (not $server_unix or not -S $path) {
    unless ($server_unix) {
      dbg "spamd: socket path might have been truncated due to system limits\n";
      die "spamd: could not create UNIX socket on $path: $!\n";
    }
    my $hostpath = $server_unix->hostpath();
    if ($hostpath ne $path) {
      warn "spamd: socket path was truncated at position " . length($hostpath) . "\n";
      warn "spamd: leaving stale socket at $hostpath\n" if -S $hostpath;
      die "spamd: path length for UNIX socket on $path exceeds system limit, exiting\n";
    }
    else {
      die "spamd: could not find newly-created UNIX socket on $path: $!\n";
    }
  }

  my $mode = $opt{socketmode};
  if ($mode) {
    $mode = oct $mode;
  } else {
    $mode = 0666;        # default
  }

  my $owner = $opt{socketowner};
  my $group = $opt{socketgroup};
  if ($owner || $group) {
    my $uid = -1;
    my $gid = -1;
    if ($owner) {
      my ($login,$pass,$puid,$pgid) = getpwnam($owner)
                           or die "spamd: $owner not in passwd database\n";
      $uid = $puid;
    }
    if ($group) {
      my ($name,$pass,$ggid,$members) = getgrnam($group)
                           or die "spamd: $group not in group database\n";
      $gid = $ggid;
    }
    if (!chown $uid, $gid, $path) {
      die "spamd: could not chown $path to $uid/$gid: $!";
    }
  }

  if (!chmod $mode, $path) {    # make sure everybody can talk to it
    die "spamd: could not chmod $path to $mode: $!";
  }
}

sub server_sock_setup_ssl {
  my %socket = (
    LocalAddr       => $addr,
    LocalPort       => $sslport,
    Proto           => $proto,
    Type            => SOCK_STREAM,
    ReuseAddr       => 1,
    Listen          => SOMAXCONN,
    SSL_version     => $sslversion,
    SSL_verify_mode => 0x00,
    SSL_key_file    => $opt{'server-key'},
    SSL_cert_file   => $opt{'server-cert'}
  );
  dbg("spamd: creating SSL socket:\n" . join("\n", map { " $_:  " . (defined $socket{$_} ? $socket{$_} : "(undef)") } sort keys %socket));
  $server_ssl = new IO::Socket::SSL(%socket)
       || die "spamd: could not create SSL socket on $addr:$sslport: $!\n";
}

sub server_sock_setup_inet {
  my %socket = (
    LocalAddr => $addr,
    LocalPort => $inetport,
    Proto     => $proto,
    Type      => SOCK_STREAM,
    ReuseAddr => 1,
    Listen    => SOMAXCONN
  );
  dbg("spamd: creating INET socket:\n" . join("\n", map { " $_: " . (defined $socket{$_} ? $socket{$_} : "(undef)") } sort keys %socket));
  $server_inet = new_io_socket_inetx(%socket)
       || die "spamd: could not create INET socket on $addr:$inetport: $!\n";
}

# ---------------------------------------------------------------------------

# for select() purposes: make a map of the server socket FDs
map_server_sockets();

if ( defined $opt{'pidfile'} ) {
  $opt{'pidfile'} =
    Mail::SpamAssassin::Util::untaint_file_path( $opt{'pidfile'} );
}


my $spamtest = Mail::SpamAssassin->new(
  {
    dont_copy_prefs      => $dontcopy,
    rules_filename       => ( $opt{'configpath'} || 0 ),
    site_rules_filename  => ( $opt{'siteconfigpath'} || 0 ),
    post_config_text     => join("\n", @{$opt{'cf'}})."\n",
    force_ipv4           => ( $opt{'force_ipv4'} || 0 ),
    local_tests_only     => ( $opt{'local'} || 0 ),
    debug                => ( $opt{'debug'} || 0 ),
    paranoid             => ( $opt{'paranoid'} || 0 ),
    home_dir_for_helpers => (
      defined $opt{'home_dir_for_helpers'}
      ? $opt{'home_dir_for_helpers'}
      : $orighome
    ),
    PREFIX          => $PREFIX,
    DEF_RULES_DIR   => $DEF_RULES_DIR,
    LOCAL_RULES_DIR => $LOCAL_RULES_DIR,
    LOCAL_STATE_DIR => $LOCAL_STATE_DIR
  }
);

$spamtest->init_learner({
  opportunistic_expire_check_only => 1,
});

# if $clients_per_child == 1, there's no point in copying configs around
unless ($clients_per_child > 1) {
  # unset $copy_config_p so we don't bother trying to copy things back
  # after closing the connection
  $copy_config_p = 0;
}

## DAEMONIZE! ##

$opt{'daemonize'} and daemonize();

# bug 3443: setup signal handlers before the kids since we may have to
# kill them...  make sure this happens before setting up the pidfile to
# avoid a race condition.
my $got_sighup;
setup_parent_sig_handlers();

# should be done post-daemonize such that any files created by this
# process are written with the right ownership and everything.
preload_modules_with_tmp_homedir();

# bayes DBs may still be tied() at this point, so untie them and such.
$spamtest->finish_learner();

# If we're going to be switching users in check(), let's backup the
# fresh configuration now for later restoring ...  MUST be placed after
# the M::SA creation.
my %conf_backup = ();
my %msa_backup = ();

if ($copy_config_p) {
  foreach( 'username', 'user_dir', 'userstate_dir', 'learn_to_journal' ) {
    $msa_backup{$_} = $spamtest->{$_} if (exists $spamtest->{$_});
  }

  $spamtest->copy_config(undef, \%conf_backup) ||
    die "spamd: error returned from copy_config\n";
}

# bonus: SIGUSR2 to dump a stack trace.  this is never reset
my $current_msgid = "(none)";
$SIG{USR2} = \&backtrace_handler;

# log server started, but processes watching the log to wait for connect
# should wait until they see the pid, after signal handlers are in place
# FIXME: two calls are one too much
info("spamd: server started on $listeninfo (running version "
     . Mail::SpamAssassin::Version() . ")" );

my $remote_port;

# Make the pidfile ...
if (defined $opt{'pidfile'}) {
  if (open PIDF, ">$opt{'pidfile'}") {
    print PIDF "$$\n";
    close PIDF;
  }
  else {
    warn "spamd: cannot write to PID file: $!\n";
  }
}

# now allow waiting processes to connect, if they're watching the log.
# The test suite does this!
info("spamd: server pid: $$\n");

# Fork off our children.
for ( 1 .. $childlimit ) {
  spawn();
}

if ($scaling) {
  $scaling->set_server_fh($server_inet, $server_unix, $server_ssl);
}

while (1) {
  if (!$scaling) {
    # wait for a signal (ie: child's death)
    # bug 4190: use a time-limited sleep, and call child_handler() even
    # if haven't received a SIGCHLD, due to inherent race condition
    sleep 10;
    child_handler();
  } else {
    $scaling->main_server_poll($opt{'server-scale-period'});
  }

  if ( defined $got_sighup ) {
    if (defined($opt{'pidfile'})) {
      unlink($opt{'pidfile'}) || warn "spamd: cannot unlink $opt{'pidfile'}: $!\n";
    }

    # leave Client fds active, and do not kill children; they can still
    # service clients until they exit.  But restart the listener anyway.
    # And close the logfile, so the new instance can reopen it.
    Mail::SpamAssassin::Logger::close_log();
    chdir($ORIG_CWD)
      || die "spamd: restart failed: chdir failed: ${ORIG_CWD}: $!\n";

    # ensure we re-run spamd using the right perl interpreter, and
    # with the right switches (taint mode and warnings) (bug 5255)
    my $perl = Mail::SpamAssassin::Util::untaint_var($^X);
    my @execs = ( $perl, "-T", "-w", $ORIG_ARG0, @ORIG_ARGV );
    warn "spamd: restarting using '" . join (' ', @execs) . "'\n";
    exec @execs;

    # should not get past that...
    die "spamd: restart failed: exec failed: " . join (' ', @execs) . ": $!\n";
  }

  for (my $i = keys %children; $i < $childlimit; $i++) {
    spawn();
  }
}

# Kicks off a kid ...
sub spawn {
  my $pid;

  $backchannel->setup_backchannel_parent_pre_fork();

  # block signal for fork
  my $sigset = POSIX::SigSet->new( POSIX::SIGINT(), POSIX::SIGCHLD() );
  sigprocmask( POSIX::SIG_BLOCK(), $sigset )
    or die "spamd: cannot block SIGINT/SIGCHLD for fork: $!\n";

  $pid = fork();
  die "spamd: fork: $!" unless defined $pid;

  if ($pid) {
    ## PARENT

    $children{$pid} = 1;
    info("spamd: server successfully spawned child process, pid $pid");
    $backchannel->setup_backchannel_parent_post_fork($pid);
    if ($scaling) {
      $scaling->add_child($pid);
    }
    sigprocmask( POSIX::SIG_UNBLOCK(), $sigset )
      or die "spamd: cannot unblock SIGINT/SIGCHLD for fork: $!\n";
    return;
  }
  else {
    ## CHILD

    # Reset signal handling to default settings, and unblock.
    # These lines must be as soon as possible after the fork (bug 4304)
    setup_child_sig_handlers();
    sigprocmask( POSIX::SIG_UNBLOCK(), $sigset )
      or die "spamd: cannot unblock SIGINT/SIGCHLD for fork: $!\n";

    $spamtest->call_plugins("spamd_child_init");

    # support non-root use
    if ( $opt{'username'} ) {
      my ( $uuid, $ugid ) = ( getpwnam( $opt{'username'} ) )[ 2, 3 ];
      if ( !defined $uuid || $uuid == 0 ) {
        die "spamd: cannot run as nonexistent user or root with -u option\n";
      }

      if ( $opt{'groupname'} ) {
        $ugid = getgrnam( $opt{'groupname'} ) || $ugid;
      }

      # Change GID
      $) = "$ugid $ugid";    # effective gid
      $( = $ugid;            # real gid

      # Change UID
      $> = $uuid;            # effective uid
      $< = $uuid;            # real uid. we now cannot setuid anymore

      # bug 3900: BSD perl bug. see comment in setuid_to_euid() in
      # Mail::SA::Util on the same issue.
      if ($< != $uuid) {
        dbg("spamd: initial attempt to change real uid failed, trying BSD workaround");

        $> = $<;              # revert euid to ruid
        $< = $uuid;           # change ruid to target
        $> = $uuid;           # change euid back to target
      }

      if ( $> != $uuid and $> != ( $uuid - 2**32 ) ) {
        die "spamd: setuid to uid $uuid failed\n";
      }
    }

    # set process name where supported
    # this will help make it clear via process listing which is child/parent
    $0 = 'spamd child';

    $backchannel->setup_backchannel_child_post_fork();
    if ($scaling) {     # only do this once, for efficiency; $$ is a syscall
      $scaling->set_my_pid($$);
    }

    # handle $clients_per_child connections, then die in "old" age...
    my $orders;
    for ( my $i = 0 ; $i < $clients_per_child ; $i++ ) {
      if ($scaling) {
        $scaling->update_child_status_idle();
        $orders = $scaling->wait_for_orders(); # and sleep...

        if ($orders != PFORDER_ACCEPT) {
          info("spamd: unknown order: $orders");
        }
      }

      # use a large eval scope to catch die()s and ensure they
      # don't kill the server.
      my $evalret = eval { accept_a_conn(); };

      if (!defined ($evalret)) {
        warn("spamd: error: $@ $!, continuing");
        if ($client) { $client->close(); }  # avoid fd leaks
      }
      elsif ($evalret == -1) {
        # serious error; used for accept() failure
        die("spamd: respawning server");
      }

      $spamtest->call_plugins("spamd_child_post_connection_close");

      # if we changed UID during processing, change back!
      if ($setuid_to_user && ($> != $<) && ($> != ($< - 2**32))) {
        $) = "$( $(";    # change eGID
        $> = $<;         # change eUID

        # check again; ensure the change happened
        if ($> != $< && ($> != ( $< - 2**32))) {
          # make it fatal to avoid security breaches
          die("spamd: return setuid failed");
        }
      }

      if ($copy_config_p) {
        # use a timeout!  There are bugs in Storable on certain platforms
        # that can cause spamd to hang -- see bug 3828 comment 154.
        # we don't use Storable any more, but leave this in -- just
        # in case.
	# bug 4699: this is the alarm that often ends up with an empty $@

	my $timer = Mail::SpamAssassin::Timeout->new({ secs => 20 });
	my $err = $timer->run(sub {	

          while(my($k,$v) = each %msa_backup) {
            $spamtest->{$k} = $v;
          }

          # if we changed user, we would have also loaded up new configs
          # (potentially), so let's restore back the saved version we
          # had before.
          $spamtest->copy_config(\%conf_backup, undef) ||
            die "spamd: error returned from copy_config\n";
        });

	if ($timer->timed_out()) {
	  warn("spamd: copy_config timeout, respawning child process after ".
		($i+1)." messages");
	  exit;		# so that the master spamd can respawn
	}
      }
      undef $current_user;

    }

    # If the child lives to get here, it will die ...  Muhaha.
    exit;
  }
}

sub accept_from_any_server_socket {

  my $fdvec = $server_select_mask;

  if ($have_multiple_server_socks) {
    # determine which of our server FDs is ready using select().
    # We only need to do this if we have more than one server
    # socket supported, since otherwise there can only be one socket
    # with a client waiting.
    # (TODO: we could extend the prefork protocol to pass this data)
    my $nfound = select($fdvec, undef, undef, 0.1);
    die "oops? accept_a_conn: no fds ready" unless $nfound;
  }

  if ($fd_inet && vec $fdvec, $fd_inet, 1) {
    $client = $server_inet->accept;
  }
  elsif ($fd_unix && vec $fdvec, $fd_unix, 1) {
    $client = $server_unix->accept;
  }
  elsif ($fd_ssl && vec $fdvec, $fd_ssl, 1) {
    $client = $server_ssl->accept;
  }
  else {
    die "accept_a_conn: no fds ready by vec: $fdvec";
  }
  return $client;
}

sub accept_a_conn {
  $client = accept_from_any_server_socket();

  if ($scaling) {
    $scaling->update_child_status_busy();
  }

  # Bah!
  if ( !$client  || !defined $client->connected() ) {

    # this can happen when interrupted by SIGCHLD on Solaris,
    # perl 5.8.0, and some other platforms with -m.
    if ( $! == &Errno::EINTR ) {
      return 0;
    }
    elsif ( $! == 0 && $listen_ssl ) {
      warn("spamd: SSL failure: " . &IO::Socket::SSL::errstr());
      return 0;
    }
    else {
      warn("spamd: accept failed: $!");
      return -1;
    }
  }

  $client->autoflush(1);

  # keep track of start time
  my $start = time;

  my ($remote_hostname, $remote_hostaddr);
  if ($opt{'socketpath'}) {
    $remote_hostname = 'localhost';
    $remote_hostaddr = '127.0.0.1';
    $remote_port = $opt{'socketpath'};
    info("spamd: got connection over " . $opt{'socketpath'});
  }
  else {
    ($remote_port, $remote_hostaddr, $remote_hostname) =
      peer_info_from_socket($client)
      or die 'failed to obtain port and ip from socket';

    my $msg = "connection from ${remote_hostname} [${remote_hostaddr}] at port ${remote_port}";
    if (ip_is_allowed($remote_hostaddr)) {
      info("spamd: $msg");
    }
    else {
      warn("spamd: unauthorized $msg");
      $client->close;
      return 0;
    }
  }

  local ($_);
  eval {
    Mail::SpamAssassin::Util::trap_sigalrm_fully(sub {
                          die "tcp timeout";
                        });
    alarm $timeout_tcp if ($timeout_tcp);
    # send the request to the child process
    $_ = $client->getline;
  };
  alarm 0;

  if ($@) {
    if ($@ =~ /tcp timeout/) {
      service_timeout("($timeout_tcp second socket timeout reading input from client)");
    } else {
      warn "spamd: $@";
    }
    $client->close;
    return 0;
  }

  if ( !defined $_ ) {
    protocol_error("(closed before headers)");
    $client->close;
    return 0;
  }

  s/\r?\n//;

  # It may be a SKIP message, meaning that the client (spamc)
  # thinks it is too big to check.  So we don't do any real work
  # in that case.

  if (/SKIP SPAMC\/(.*)/) {
    info(sprintf("spamd: skipped large message in %3d seconds", time - $start));
  }

  # It might be a CHECK message, meaning that we should just check
  # if it's spam or not, then return the appropriate response.
  # If we get the PROCESS command, the client is going to send a
  # message that we need to filter.

  elsif (/(PROCESS|CHECK|SYMBOLS|REPORT|HEADERS|REPORT_IFSPAM) SPAMC\/(.*)/) {
    my $method = $1;
    my $version = $2;
    eval {
      Mail::SpamAssassin::Util::trap_sigalrm_fully(sub {
                          die "child processing timeout";
                        });
      alarm $timeout_child if ($timeout_child);
      check($method, $version, $start, $remote_hostname, $remote_hostaddr);
    };
    alarm 0;

    if ($@) {
      if ($@ =~ /child processing timeout/) {
        service_timeout("($timeout_child second timeout while trying to $method)");
      } else {
	warn "spamd: $@";
      }
      $client->close();
      return 0;
    }
  }

  elsif (/(TELL) SPAMC\/(.*)/) {
    my $method = $1;
    my $version = $2;
    eval {
      Mail::SpamAssassin::Util::trap_sigalrm_fully(sub {
						     die "child processing timeout";
						   });
      alarm $timeout_child if ($timeout_child);
      dotell($method, $version, $start, $remote_hostname, $remote_hostaddr);
    };
    alarm 0;

    if ($@) {
      if ($@ =~ /child processing timeout/) {
        service_timeout("($timeout_child second timeout while trying to $method)");
      } else {
	warn "spamd: $@";
      }
      $client->close();
      return 0;
    }
  }

  # Looks like a client is just seeing if we're alive.

  elsif (/PING SPAMC\/(.*)/) {
    syswrite( $client, "SPAMD/1.4 $resphash{EX_OK} PONG\r\n" );
  }

  # If it was none of the above, then we don't know what it was.

  else {
    protocol_error($_);
  }

  # Close out our connection to the client ...
  $client->close();
  return 1;
}

sub handle_setuid_to_user {
  if ($spamtest->{paranoid}) {
    die("spamd: in paranoid mode, still running as root: closing connection");
  }
  warn("spamd: still running as root: user not specified with -u, "
       . "not found, or set to root, falling back to nobody\n");

  my ($name, $pwd, $uid, $gid, $quota, $comment, $gcos, $dir, $etc) =
      getpwnam('nobody');
  
  $) = "$gid $gid";                   # eGID
  $> = $uid;                          # eUID
  if (!defined($uid) || ($> != $uid and $> != ($uid - 2**32))) {
    die("spamd: setuid to nobody failed");
  }

  $spamtest->signal_user_changed(
    {
      username => $name,
      user_dir => $dir
    }
  );
}

sub parse_body {
  my ($client, $expected_length, $compress_zlib) = @_;

  my @msglines;
  my $actual_length;

  if ($compress_zlib && !defined($expected_length)) {
    service_unavailable_error("Compress requires Content-length header");
    return;
  }

  if ($compress_zlib) {
    $actual_length = zlib_inflate_read($client, $expected_length, \@msglines);
    if ($actual_length < 0) { return; }
    $expected_length = $actual_length;
  }
  else {
    @msglines = ();
    $actual_length = 0;
    while (defined($_ = $client->getline())) {
      $actual_length += length($_);
      push(@msglines, $_);    
      last if (defined $expected_length && $actual_length >= $expected_length);
    }
  }
  
  # Now parse *only* the message headers; the MIME tree won't be generated 
  # yet, it will be done on demand later on.
  my $mail = $spamtest->parse(\@msglines, 0);

  return ($mail, $actual_length);
}

sub zlib_inflate_read {
  my ($client, $expected_length, $msglinesref) = @_;
  my $out;
  my $actual_length;

  eval {
    require Compress::Zlib;
    my ($zlib, $status) = Compress::Zlib::inflateInit();
    if (!$zlib) { die "inflateInit failed: $status"; }

    my $red = 0;
    my $buf;

    # TODO: inflate in smaller buffers instead of at EOF
    while (1) {
      my $numbytes = $client->read($buf, (1024 * 64) + $red, $red);
      if (!defined $numbytes) {
        die "read of zlib data failed: $!";
        return -1;
      }
      last if $numbytes == 0;
      $red += $numbytes;
    }

    if ($red > $expected_length) {
      warn "hmm, zlib read $red > expected_length $expected_length";
      substr ($buf, $expected_length) = '';
    }

    ($out, $status) = $zlib->inflate($buf);
    if ($status != Compress::Zlib::Z_STREAM_END()) {
      die "failed to find end of zlib stream";
    }
  };

  if ($@) { 
    service_unavailable_error("zlib: $@");
    return -1;
  }

  $actual_length = length($out);

  # TODO: split during inflate, too
  # note that this preserves line endings
  @{$msglinesref} = map { s/$/\n/gs; $_; } split(/\n/, $out);
  return $actual_length;
}

sub parse_msgids {
  my ($mail) = @_;

  # Extract the Message-Id(s) for logging purposes.
  my $msgid  = $mail->get_pristine_header("Message-Id");
  my $rmsgid = $mail->get_pristine_header("Resent-Message-Id");
  foreach my $id ((\$msgid, \$rmsgid)) {
    if ( $$id ) {
      while ( $$id =~ s/\([^\(\)]*\)// )
         { }                           # remove comments and
      $$id =~ s/^\s+|\s+$//g;          # leading and trailing spaces
      $$id =~ s/\s+/ /g;               # collapse whitespaces
      $$id =~ s/^.*?<(.*?)>.*$/$1/;    # keep only the id itself
      $$id =~ s/[^\x21-\x7e]/?/g;      # replace all weird chars
      $$id =~ s/[<>]/?/g;              # plus all dangling angle brackets
      $$id =~ s/^(.+)$/<$1>/;          # re-bracket the id (if not empty)
    }
  }
  return ($msgid, $rmsgid);
}

sub check {
  my ( $method, $version, $start_time, $remote_hostname, $remote_hostaddr ) = @_;
  local ($_);
  my $expected_length;
  my $compress_zlib;

  # used to ensure we don't accidentally fork (bug 4370)
  my $starting_self_pid = $$;

  # Protocol version 1.0 and greater may have "User:" and
  # "Content-length:" headers.  But they're not required.

  if ( $version > 1.0 ) {
    my $hdrs = {};

    return 0 unless (parse_headers($hdrs, $client));

    $expected_length = $hdrs->{expected_length};
    $compress_zlib = $hdrs->{compress_zlib};
  }

  return 0 unless do_user_handling();
  if ($> == 0) { die "spamd: still running as root! dying"; }

  my $resp = "EX_OK";

  # generate mail object from input
  my ($mail, $actual_length) = parse_body($client, $expected_length,
                $compress_zlib);
  return 0 unless defined($mail);       # error

  if ($compress_zlib) {
    $expected_length = $actual_length;  # previously it was the gzipped length
  }

  # attempt to fetch the message ids
  my ($msgid, $rmsgid) = parse_msgids($mail);

  $msgid        ||= "(unknown)";
  $current_user ||= "(unknown)";
  $current_msgid = $msgid;      # for the SIGUSR2 backtrace
  info("spamd: " . ($method eq 'PROCESS' ? "processing" : "checking")
       . " message $msgid"
       . ( $rmsgid ? " aka $rmsgid" : "" )
       . " for ${current_user}:$>");

  # Check length if we're supposed to.
  if (defined $expected_length && $actual_length != $expected_length) {
    protocol_error(
      "(Content-Length mismatch: Expected $expected_length bytes, got $actual_length bytes)"
    );
    $mail->finish();
    return 0;
  }

  # Go ahead and check the message
  $spamtest->init(1);
  my $status = Mail::SpamAssassin::PerMsgStatus->new($spamtest, $mail);
  $status->check();

  my $msg_score     = sprintf( "%.1f", $status->get_score );
  my $msg_threshold = sprintf( "%.1f", $status->get_required_score );

  my $response_spam_status = "";
  my $was_it_spam;
  if ( $status->is_spam ) {
    $response_spam_status = $method eq "REPORT_IFSPAM" ? "Yes" : "True";
    $was_it_spam = 'identified spam';
  }
  else {
    $response_spam_status = $method eq "REPORT_IFSPAM" ? "No" : "False";
    $was_it_spam = 'clean message';
  }

  my $spamhdr = "Spam: $response_spam_status ; $msg_score / $msg_threshold";

  if ( $method eq 'PROCESS' || $method eq 'HEADERS' ) {

    $status->set_tag('REMOTEHOSTNAME', $remote_hostname);
    $status->set_tag('REMOTEHOSTADDR', $remote_hostaddr);

    # Build the message to send back and measure it
    my $msg_resp        = $status->rewrite_mail();

    if ($method eq 'HEADERS') {
      # just the headers; delete everything after first \015\012\015\012
      $msg_resp =~ s/(\015?\012\015?\012).*$/$1/gs;
    }

    my $msg_resp_length = length($msg_resp);

    if ( $version >= 1.3 )    # Spamc protocol 1.3 means multi hdrs are OK
    {
      syswrite_full_buffer( $client, "SPAMD/1.1 $resphash{$resp} $resp\r\n" .
        "Content-length: $msg_resp_length\r\n" . $spamhdr . "\r\n\r\n" .
        $msg_resp );
    }
    elsif (
      $version >= 1.2 )    # Spamc protocol 1.2 means it accepts content-length
    {
      syswrite_full_buffer( $client, "SPAMD/1.1 $resphash{$resp} $resp\r\n" .
        "Content-length: $msg_resp_length\r\n\r\n" . $msg_resp );
    }
    else                   # Earlier than 1.2 didn't accept content-length
    {
      syswrite_full_buffer( $client, "SPAMD/1.0 $resphash{$resp} $resp\r\n" . $msg_resp );
    }
  }
  else                     # $method eq 'CHECK' et al
  {
    syswrite_full_buffer( $client, "SPAMD/1.1 $resphash{$resp} $resp\r\n" );

    if ( $method eq "CHECK" ) {
      syswrite( $client, "$spamhdr\r\n\r\n" );
    }
    else {
      my $msg_resp = '';

      if ( $method eq "REPORT"
        or ( $method eq "REPORT_IFSPAM" and $status->is_spam ) )
      {
        $msg_resp = $status->get_report;
      }
      elsif ( $method eq "REPORT_IFSPAM" ) {

        # message is ham, $msg_resp remains empty
      }
      elsif ( $method eq "SYMBOLS" ) {
        $msg_resp = $status->get_names_of_tests_hit;
        $msg_resp .= "\r\n" if ( $version < 1.3 );
      }
      else {
        die "spamd: unknown method $method";
      }

      if ( $version >= 1.3 )    # Spamc protocol > 1.2 means multi hdrs are OK
      {
        my $msg_resp_length = length($msg_resp);
        syswrite_full_buffer( $client,
                  "Content-length: $msg_resp_length\r\n" . 
                  $spamhdr . "\r\n\r\n" . $msg_resp );
      }
      else {
        syswrite_full_buffer( $client, $spamhdr . "\r\n\r\n" . $msg_resp );
      }
    }
  }

  my $scantime = sprintf( "%.1f", time - $start_time );

  info("spamd: $was_it_spam ($msg_score/$msg_threshold) for $current_user:$> in"
       . " $scantime seconds, $actual_length bytes." );

  # add a summary "result:" line, based on mass-check format
  my @extra;
  push(@extra, "scantime=".$scantime, "size=$actual_length",
            "user=".$current_user, "uid=".$>,
            "required_score=".$msg_threshold,
            "rhost=".$remote_hostname, "raddr=".$remote_hostaddr,
            "rport=".$remote_port);

  {
    my $safe = $msgid; $safe =~ s/[\x00-\x20\s,]/_/gs; push(@extra, "mid=$safe");
  }
  if ($rmsgid) {
    my $safe = $rmsgid; $safe =~ s/[\x00-\x20\s,]/_/gs; push(@extra, "rmid=$safe");
  }
  if (defined $status->{bayes_score}) {
    push(@extra, "bayes=".sprintf("%06f", $status->{bayes_score}));
  }
  push(@extra, "autolearn=".$status->get_autolearn_status());
  push(@extra, $status->get_spamd_result_log_items());

  my $yorn = $status->is_spam() ? 'Y' : '.';
  my $score = $status->get_score();
  my $tests = join(",", sort(grep(length,$status->get_names_of_tests_hit())));

  my $log = sprintf("spamd: result: %s %2d - %s %s", $yorn, $score,
	       $tests, join(",", @extra));
  info($log);

  # bug 3808: log scan results to any listening plugins, too
  $spamtest->call_plugins("log_scan_result", { result => $log });

  # bug 3466: handle the bayes expiry bits after the results were returned to
  # the client.  keeps clients from timing out.  if bayes_expiry_due is set,
  # then the opportunistic check has already checked.  go ahead and do another
  # sync/expire run.
  if ($status->{'bayes_expiry_due'}) {
    dbg("spamd: bayes expiry was marked as due, running post-check");
    $spamtest->rebuild_learner_caches();
    $spamtest->finish_learner();
  }

  $status->finish();    # added by jm to allow GC'ing
  $mail->finish();

  # ensure we didn't accidentally fork (bug 4370)
  if ($starting_self_pid != $$) {
    eval { warn("spamd: accidental fork: $$ != $starting_self_pid"); };
    POSIX::_exit(1);        # avoid END and dtor processing
  }

  return 1;
}

sub dotell {
  my ($method, $version, $start_time, $remote_hostname, $remote_hostaddr) = @_;
  local ($_);

  my $hdrs = {};

  return 0 unless (parse_headers($hdrs, $client));

  my $expected_length = $hdrs->{expected_length};
  my $compress_zlib = $hdrs->{compress_zlib};

  return 0 unless do_user_handling();
  if ($> == 0) { die "spamd: still running as root! dying"; }

  if (!$opt{tell}) {
    service_unavailable_error("TELL commands have not been enabled.");
    return 0;
  }

  if ($hdrs->{set_local} && $hdrs->{remove_local}) {
    protocol_error("Unable to set local and remove local in the same operation.");
    return 0;
  }

  if ($hdrs->{set_remote} && $hdrs->{remove_remote}) {
    protocol_error("Unable to set remote and remove remote in the same operation.");
    return 0;
  }

  if ($opt{'sql-config'} && !defined($current_user)) {
    unless (handle_user_sql('nobody')) {
      service_unavailable_error("Error fetching user preferences via SQL");
      return 0;
    }
  }

  if ($opt{'ldap-config'} && !defined($current_user)) {
    handle_user_ldap('nobody');
  }

  my $resp = "EX_OK";

  # generate mail object from input
  my ($mail, $actual_length) = parse_body($client, $expected_length,
                $compress_zlib);
  return 0 unless defined($mail);       # error

  if ($compress_zlib) {
    $expected_length = $actual_length;  # previously it was the gzipped length
  }

  if ( $mail->get_header("X-Spam-Checker-Version") ) {
    my $new_mail = $spamtest->parse($spamtest->remove_spamassassin_markup($mail), 1);
    $mail->finish();
    $mail = $new_mail;
  }

  # attempt to fetch the message ids
  my ($msgid, $rmsgid) = parse_msgids($mail);

  $msgid        ||= "(unknown)";
  $current_user ||= "(unknown)";

  # Check length if we're supposed to.
  if (defined $expected_length && $actual_length != $expected_length) {
    protocol_error("(Content-Length mismatch: Expected $expected_length bytes, got $actual_length bytes)");
    $mail->finish();
    return 0;
  }

  my @did_set;
  my @did_remove;

  if ($hdrs->{set_local}) {
    my $status = $spamtest->learn($mail, undef, ($hdrs->{message_class} eq 'spam' ? 1 : 0), 0);

    push(@did_set, 'local') if ($status->did_learn());
    $status->finish();
  }

  if ($hdrs->{remove_local}) {
    my $status = $spamtest->learn($mail, undef, undef, 1);

    push(@did_remove, 'local') if ($status->did_learn());
    $status->finish();
  }

  if ($hdrs->{set_remote}) {
    require Mail::SpamAssassin::Reporter;
    my $msgrpt = Mail::SpamAssassin::Reporter->new($spamtest, $mail);

    push(@did_set, 'remote') if ($msgrpt->report());
  }

  if ($hdrs->{remove_remote}) {
    require Mail::SpamAssassin::Reporter;
    my $msgrpt = Mail::SpamAssassin::Reporter->new($spamtest, $mail);

    push(@did_remove, 'remote') if ($msgrpt->revoke());
  }

  my $hdr = "";
  my $info_str;

  if (scalar(@did_set)) {
    $hdr .= "DidSet: " . join(',', @did_set) . "\r\n";
    $info_str .= " Setting " . join(',', @did_set) . " ";
  }

  if (scalar(@did_remove)) {
    $hdr .= "DidRemove: " . join(',', @did_remove) . "\r\n";
    $info_str .= " Removing " . join(',', @did_remove) . " ";
  }

  if (!$info_str) {
    $info_str = " Did nothing ";
  }

  print $client "SPAMD/1.1 $resphash{$resp} $resp\r\n",
    $hdr . "\r\n\r\n";

  my $scantime = sprintf( "%.1f", time - $start_time );

  info("spamd: Tell:${info_str}for $current_user:$> in"
       . " $scantime seconds, $actual_length bytes");

  $mail->finish();
  return 1;
}

###########################################################################

sub do_user_handling {
  if ($setuid_to_user && $> == 0) {
    handle_setuid_to_user();
  }

  if ( $opt{'sql-config'} && !defined($current_user) ) {
    unless ( handle_user_sql('nobody') ) {
      service_unavailable_error("Error fetching user preferences via SQL");
      return 0;
    }
  }

  if ( $opt{'ldap-config'} && !defined($current_user) ) {
    handle_user_ldap('nobody');
  }

  dbg ("spamd: running as uid $>");
  return 1;
}

# generalised header parser.  
sub parse_headers {
  my ($hdrs, $client) = @_;

  my $got_user_header;

  # max 255 headers
  for my $hcount ( 0 .. 255 ) {
    my $line = $client->getline;

    unless (defined $line) {
      protocol_error("(EOF during headers)");
      return 0;
    }
    $line =~ s/\r\n$//;

    if (!length $line) {    # end of headers
      if (!$got_user_header && $opt{'auth-ident'}) {
        service_unavailable_error('User header required');
        return 0;
      }
      return 1;
    }

    my ($header, $value) = split (/:\s*/, $line, 2);
    unless (defined $value) {
      protocol_error("(header not in 'Name: value' format)");
      return 0;
    }

    if ($header eq 'Content-length') {
      return 0 unless got_clen_header($hdrs, $header, $value);
    }
    elsif ($header eq 'User') {
      return 0 unless got_user_header($hdrs, $header, $value);
      $got_user_header++;
    }
    elsif ($header eq 'Message-class') {
      return 0 unless got_message_class_header($hdrs, $header, $value);
    }
    elsif ($header eq 'Set') {
      return 0 unless got_set_header($hdrs, $header, $value);
    }
    elsif ($header eq 'Remove') {
      return 0 unless got_remove_header($hdrs, $header, $value);
    }
    elsif ($header eq 'Compress') {
      return 0 unless &got_compress_header($hdrs, $header, $value);
    }
  }

  # avoid too-many-headers DOS attack
  protocol_error("(too many headers)");
  return 0;
}

# We'll run handle user unless we've been told not
# to process per-user config files.  Otherwise
# we'll check and see if we need to try SQL
# lookups.  If $opt{'user-config'} is true, we need to try
# their config file and then do the SQL lookup.
# If $opt{'user-config'} IS NOT true, we skip the conf file and
# only need to do the SQL lookup if $opt{'sql-config'} IS
# true.  (I got that wrong the first time.)
#
sub got_user_header {
  my ( $client, $header, $value ) = @_;

  if ( $value !~ /^([\x20-\xFF]*)$/ ) {
    protocol_error("(User header contains control chars)");
    return 0;
  }

  $current_user = $1;
  if ($opt{'auth-ident'} && !auth_ident($current_user)) {
    return 0;
  }

  if ( !$opt{'user-config'} ) {
    if ( $opt{'sql-config'} ) {
      unless ( handle_user_sql($current_user) ) {
        service_unavailable_error("Error fetching user preferences via SQL");
	return 0;
      }
    }
    elsif ( $opt{'ldap-config'} ) {
      handle_user_ldap($current_user);
    }
    elsif ( $opt{'virtual-config-dir'} ) {
      handle_virtual_config_dir($current_user);
    }
    elsif ( $opt{'setuid-with-sql'} ) {
      unless ( handle_user_setuid_with_sql($current_user) ) {
        service_unavailable_error("Error fetching user preferences via SQL");
	return 0;
      }
      $setuid_to_user = 1;    #to benefit from any paranoia.
    }
    elsif ( $opt{'setuid-with-ldap'} ) {
      handle_user_setuid_with_ldap($current_user);
      $setuid_to_user = 1;    # as above
    }
    else {
      handle_user_setuid_basic($current_user);
    }
  }
  else {
    handle_user_setuid_basic($current_user);
    if ( $opt{'sql-config'} ) {
      unless ( handle_user_sql($current_user) ) {
        service_unavailable_error("Error fetching user preferences via SQL");
	return 0;
      }
    }
  }
  return 1;
}

sub got_clen_header {
  my ( $hdrs, $header, $value ) = @_;
  if ( $value !~ /^(\d*)$/ ) {
    protocol_error("(Content-Length contains non-numeric bytes)");
    return 0;
  }
  $hdrs->{expected_length} = $1;
  return 1;
}

sub got_message_class_header {
  my ($hdrs, $header, $value) = @_;

  unless (lc($value) ne 'spam' || lc($value) ne 'ham') {
    protocol_error("(Message-class header contains invalid class)");
    return 0;
  }
  $hdrs->{message_class} = $value;

  return 1;
}

sub got_set_header {
  my ($hdrs, $header, $value) = @_;

  $hdrs->{set_local} = 0;
  $hdrs->{set_remote} = 0;

  if ($value =~ /local/i) {
    $hdrs->{set_local} = 1;
  }

  if ($value =~ /remote/i) {
    $hdrs->{set_remote} = 1;
  }

  return 1;
}

sub got_remove_header {
  my ($hdrs, $header, $value) = @_;

  $hdrs->{remove_local} = 0;
  $hdrs->{remove_remote} = 0;

  if ($value =~ /local/i) {
    $hdrs->{remove_local} = 1;
  }

  if ($value =~ /remote/i) {
    $hdrs->{remove_remote} = 1;
  }

  return 1;
}

sub got_compress_header {
  my ($hdrs, $header, $value) = @_;

  if ($value =~ /zlib/i) {
    eval { require Compress::Zlib; };
    if ($@) {
      protocol_error("(compression not supported, Compress::Zlib not installed: $@)");
      return 0;
    }
    $hdrs->{compress_zlib} = 1;
  }
  else {
    protocol_error("(compression type not supported)");
    return 0;
  }

  return 1;
}

sub protocol_error {
  my ($err) = @_;
  my $resp = "EX_PROTOCOL";
  syswrite($client, "SPAMD/1.0 $resphash{$resp} Bad header line: $err\r\n");
  warn("spamd: bad protocol: header error: $err");
}

sub service_unavailable_error {
  my ($err) = @_;
  my $resp = "EX_UNAVAILABLE";
  syswrite($client,
	   "SPAMD/1.0 $resphash{$resp} Service Unavailable: $err\r\n");
  warn("spamd: service unavailable: $err");
}

sub service_timeout {
  my ($err) = @_;
  my $resp = "EX_TIMEOUT";
  print $client "SPAMD/1.0 $resphash{$resp} Timeout: $err\r\n";
  warn("spamd: timeout: $err");
}

###########################################################################

sub auth_ident {
  my $username = shift;
  my $ident_username = ident_lookup( $client, $opt{'ident-timeout'} );
  my $dn = $ident_username || 'NONE';    # display name
  dbg("ident: ident_username = $dn, spamc_username = $username\n");
  if ( !defined($ident_username) || $username ne $ident_username ) {
    info("spamd: ident username ($dn) does not match "
	 . "spamc username ($username)" );
    return 0;
  }
  return 1;
}

sub handle_user_setuid_basic {
  my $username = shift;

  #
  # If vpopmail config enabled then look up userinfo for vpopmail uid
  # as defined by $opt{'username'} or as passed via $username
  #
  my $userid = '';
  if ( $opt{'vpopmail'} && $opt{'username'} ) {
    $userid = $opt{'username'};
  }
  else {
    $userid = $username;
  }
  my ($name, $pwd, $uid, $gid, $quota, $comment, $gcos, $dir, $etc) =
      getpwnam($userid);

  if (!defined $uid) {
      my $errmsg = "spamd: handle_user unable to find user: '$userid'\n";
      die $errmsg if $spamtest->{'paranoid'};
      # if we are given a username, but can't look it up, maybe name
      # services are down?  let's break out here to allow them to get
      # 'defaults' when we are not running paranoid
      info($errmsg);
      return 0;
  }

  if ($setuid_to_user) {
    $) = "$gid $gid";                 # change eGID
    $> = $uid;                        # change eUID
    if ( !defined($uid) || ( $> != $uid and $> != ( $uid - 2**32 ) ) ) {
      # make it fatal to avoid security breaches
      die("spamd: fatal error: setuid to $username failed");
    }
    else {
      info("spamd: setuid to $username succeeded");
    }
  }

  if ($opt{'user-config'}) {
    handle_user_set_user_prefs($dir, $username);
  }
}

sub handle_user_set_user_prefs {
  my ($dir, $username) = @_;

  #
  # If vpopmail config enabled then set $dir to virtual homedir
  #
  if ( $opt{'vpopmail'} ) {
    my $vpopdir = $dir;
    $dir = `$vpopdir/bin/vuserinfo -d \Q$username\E`;
    if ($? != 0) {
      #
      # If vuserinfo failed $username could be an alias
      #
      $dir = `$vpopdir/bin/valias \Q$username\E`;
      if ($? == 0 && $dir !~ /.+ -> &/) {
        $dir =~ s,.+ -> (/.+)/Maildir/,$1,;
      } else {
        undef($dir);
      }
    }
    chomp($dir);
  }
  my $cf_file = $dir . "/.spamassassin/user_prefs";

  create_default_cf_if_needed( $cf_file, $username, $dir );
  $spamtest->read_scoreonly_config($cf_file);
  $spamtest->signal_user_changed(
    {
      username => $username,
      user_dir => $dir
    }
  );

  return 1;
}

# Handle user configs without the necessity of having individual users or a
# SQL/LDAP database.
sub handle_virtual_config_dir {
  my ($username) = @_;

  my $dir = $opt{'virtual-config-dir'};
  my $userdir;
  my $prefsfile;

  if ( defined $dir ) {
    my $safename = $username;
    $safename =~ s/[^-A-Za-z0-9\+_\.\,\@\=]/_/gs;
    my $localpart = '';
    my $domain    = '';
    if ( $safename =~ /^(.*)\@(.*)$/ ) { $localpart = $1; $domain = $2; }

    $dir =~ s/\%u/${safename}/g;
    $dir =~ s/\%l/${localpart}/g;
    $dir =~ s/\%d/${domain}/g;
    $dir =~ s/\%\%/\%/g;

    $userdir   = $dir;
    $prefsfile = $dir . '/user_prefs';

    # Log that the default configuration is being used for a user.
    info("spamd: using default config for $username: $prefsfile");
  }

  if ( -f $prefsfile ) {

    # Found a config, load it.
    $spamtest->read_scoreonly_config($prefsfile);
  }

  # assume that $userdir will be a writable directory we can
  # use for Bayes dbs etc.
  $spamtest->signal_user_changed(
    {
      username => $username,
      userstate_dir => $userdir,
      user_dir => $userdir
    }
  );
  return 1;
}

sub handle_user_sql {
  my ($username) = @_;

  unless ( $spamtest->load_scoreonly_sql($username) ) {
    return 0;
  }
  $spamtest->signal_user_changed(
    {
      username => $username,
      user_dir => undef
    }
  );
  return 1;
}

sub handle_user_ldap {
  my $username = shift;
  dbg("ldap: entering handle_user_ldap($username)");
  $spamtest->load_scoreonly_ldap($username);
  $spamtest->signal_user_changed(
    {
      username => $username,
      user_dir => undef
    }
  );
  return 1;
}

sub handle_user_setuid_with_sql {
  my $username = shift;
  my ($name, $pwd, $uid, $gid, $quota, $comment, $gcos, $dir, $etc) =
      getpwnam($username);

  if (!$spamtest->{'paranoid'} && !defined($uid)) {
    # if we are given a username, but can't look it up, maybe name
    # services are down?  let's break out here to allow them to get
    # 'defaults' when we are not running paranoid
    info("spamd: handle_user unable to find user: $username\n");
    return 0;
  }

  if ($setuid_to_user) {
    $) = "$gid $gid";                 # change eGID
    $> = $uid;                        # change eUID
    if (!defined($uid) || ($> != $uid and $> != ($uid - 2**32))) {
      # make it fatal to avoid security breaches
      die("spamd: fatal error: setuid to $username failed");
    }
    else {
      info("spamd: setuid to $username succeeded, reading scores from SQL");
    }
  }

  my $spam_conf_dir = $dir . '/.spamassassin'; # needed for Bayes, etc.
  if (! -d $spam_conf_dir) {
    if (mkdir $spam_conf_dir, 0700) {
      info("spamd: created $spam_conf_dir for $username");
    }
    else {
      info("spamd: failed to create $spam_conf_dir for $username");
    }
  }

  unless ($spamtest->load_scoreonly_sql($username)) {
    return 0;
  }

  $spamtest->signal_user_changed( { username => $username } );
  return 1;
}

sub handle_user_setuid_with_ldap {
  my $username = shift;
  my ($name, $pwd, $uid, $gid, $quota, $comment, $gcos, $dir, $etc) =
      getpwnam($username);

  if (!$spamtest->{'paranoid'} && !defined($uid)) {
    # if we are given a username, but can't look it up, maybe name
    # services are down?  let's break out here to allow them to get
    # 'defaults' when we are not running paranoid
    info("spamd: handle_user unable to find user: $username\n");
    return 0;
  }

  if ($setuid_to_user) {
    $) = "$gid $gid";    # change eGID
    $> = $uid;           # change eUID
    if (!defined($uid) || ($> != $uid and $> != ($uid - 2**32))) {
      # make it fatal to avoid security breaches
      die("spamd: fatal error: setuid to $username failed");
    }
    else {
      info("spamd: setuid to $username succeeded, reading scores from LDAP");
    }
  }

  my $spam_conf_dir = $dir . '/.spamassassin'; # needed for Bayes, etc.
  if (! -d $spam_conf_dir) {
    if (mkdir $spam_conf_dir, 0700) {
      info("spamd: created $spam_conf_dir for $username");
    }
    else {
      info("spamd: failed to create $spam_conf_dir for $username");
    }
  }

  $spamtest->load_scoreonly_ldap($username);

  $spamtest->signal_user_changed( { username => $username } );
  return 1;
}

sub create_default_cf_if_needed {
  my ( $cf_file, $username, $userdir ) = @_;

  # Parse user scores, creating default .cf if needed:
  if ( !-r $cf_file && !$spamtest->{'dont_copy_prefs'} ) {
    info("spamd: creating default_prefs: $cf_file");

    # If vpopmail config enabled then pass virtual homedir onto
    # create_default_prefs via $userdir
    $spamtest->create_default_prefs( $cf_file, $username, $userdir );

    if (! -r $cf_file) {
      info("spamd: failed to create readable default_prefs: $cf_file");
    }
  }
}

# sig handlers: parent process
sub setup_parent_sig_handlers {
  $SIG{HUP}  = \&restart_handler;
  $SIG{CHLD} = \&child_handler;
  $SIG{INT}  = \&kill_handler;
  $SIG{TERM} = \&kill_handler;
  $SIG{PIPE} = 'IGNORE';
}

# sig handlers: child processes
sub setup_child_sig_handlers {
  # note: all the signals changed in setup_parent_sig_handlers() must
  # be reset to appropriate values here!
  $SIG{HUP} = $SIG{CHLD} = $SIG{INT} = $SIG{TERM} = 'DEFAULT';
  $SIG{PIPE} = 'IGNORE';
}

sub kill_handler {
  my ($sig) = @_;
  info("spamd: server killed by SIG$sig, shutting down");
  $server_inet and $server_inet->close;
  $server_unix and $server_unix->close;
  $server_ssl  and $server_ssl->close;

  if (defined($opt{'pidfile'})) {
    unlink($opt{'pidfile'}) || warn "spamd: cannot unlink $opt{'pidfile'}: $!\n";
  }

  # the UNIX domain socket
  if (defined($opt{'socketpath'})) {
    unlink($opt{'socketpath'}) || warn "spamd: cannot unlink $opt{'socketpath'}: $!\n";
  }

  $SIG{CHLD} = 'DEFAULT';    # we're going to kill our children
  if ($scaling) {
    $scaling->set_exiting_flag(); # don't start new ones
  }
  kill 'INT' => keys %children;
  exit 0;
}

# takes care of dead children
sub child_handler {
  my ($sig) = @_;

  # do NOT call syslog here unless the child's pid is in our list of known
  # children.  This is due to syslog-ng brokenness -- bugs 3625, 4237.

  # clean up any children which have exited
  while((my $pid = waitpid(-1, WNOHANG)) > 0) {
    if (!defined $children{$pid}) {
      # ignore this child; we didn't realise we'd forked it. bug 4237
      next;
    }

    # remove them from our child listing
    delete $children{$pid};

    if ($scaling) {
      $scaling->child_exited($pid);
    } else {
      my $sock = $backchannel->get_socket_for_child($pid);
      if ($sock) { $sock->close(); }
    }

    unless ($$Mail::SpamAssassin::Logger::LOG_SA{INHIBIT_LOGGING_IN_SIGCHLD_HANDLER}) {
      info("spamd: handled cleanup of child pid $pid ".
                ((defined $sig) ? "due to SIG$sig" : ""));
    }
  }

  $SIG{CHLD} = \&child_handler;    # reset as necessary, should be at end
}

sub restart_handler {
  my ($sig) = @_;
  info("spamd: server hit by SIG$sig, restarting");

  $SIG{CHLD} = 'DEFAULT';    # we're going to kill our children
  if ($scaling) {
    $scaling->set_exiting_flag(); # don't start new ones
  }

  foreach (keys %children) {
    kill 'INT' => $_;
    my $pid = waitpid($_, 0);
    if ($scaling) {
      $scaling->child_exited($pid);
    }
    info("spamd: child $pid killed successfully");
  }
  %children = ();

  unless ( !$server_inet || $server_inet->eof ) {
    $server_inet->shutdown(2);
    $server_inet->close;
    info("spamd: server INET socket closed");
  }

  unless ( !$server_unix || $server_unix->eof ) {
    $server_unix->shutdown(2);
    $server_unix->close;
    if (defined($opt{'socketpath'})) {
      unlink($opt{'socketpath'}) || warn "spamd: cannot unlink $opt{'socketpath'}: $!\n";
    }
    info("spamd: server UNIX socket closed");
  }

  unless ( !$server_ssl || $server_ssl->eof ) {
    $server_ssl->shutdown(2);
    $server_ssl->close;
    info("spamd: server SSL socket closed");
  }
  $got_sighup = 1;
}

sub backtrace_handler {
  Carp::cluck("spamd: caught SIGUSR2 - dumping backtrace. ".
        "most recent message: $current_msgid\n");
}

sub daemonize {
  # Pretty command line in ps
  $0 = join (' ', $ORIG_ARG0, @ORIG_ARGV) unless would_log("dbg");

  # be a nice daemon and chdir to the root so we don't block any
  # unmount attempts
  chdir '/' or die "spamd: cannot chdir to /: $!\n";

  # Redirect in and out to the bit bucket
  open STDIN,  "</dev/null" or die "spamd: cannot read from /dev/null: $!\n";
  open STDOUT, ">/dev/null" or die "spamd: cannot write to /dev/null: $!\n";

  # Remove the stderr logger
  Mail::SpamAssassin::Logger::remove('stderr');

  # Here we go...
  defined( my $pid = fork ) or die "spamd: cannot fork: $!\n";
  exit if $pid;
  setsid or die "spamd: cannot start new session: $!\n";

  # Now we can redirect the errors, too.
  open STDERR, '>&STDOUT' or die "spamd: cannot duplicate stdout: $!\n";

  dbg("spamd: successfully daemonized");
}

sub set_allowed_ip {
  foreach (@_) {
    $allowed_nets->add_cidr($_) or die "spamd: aborting due to add_cidr error\n";
  }
}

sub ip_is_allowed {
  $allowed_nets->contains_ip(@_);
}

sub preload_modules_with_tmp_homedir {

  # set $ENV{HOME} in /tmp while we compile and preload everything.
  # File::Spec->tmpdir uses TMPDIR, TMP, TEMP, C:/temp, /tmp etc.
  my $tmpdir = File::Spec->tmpdir();
  if ( !$tmpdir ) {
    die "spamd: cannot find writable tmp dir, set TMP or TMPDIR in environment";
  }

  # If TMPDIR isn't set, File::Spec->tmpdir() will set it to undefined.
  # that then breaks other things ...
  delete $ENV{'TMPDIR'} if ( !defined $ENV{'TMPDIR'} );

  my $tmphome = File::Spec->catdir( $tmpdir, "spamd-$$-init" );
  $tmphome = Mail::SpamAssassin::Util::untaint_file_path($tmphome);

  my $tmpsadir = File::Spec->catdir( $tmphome, ".spamassassin" );

  dbg("spamd: Preloading modules with HOME=$tmphome");

  # bug 5379: spamd won't start if the temp preloading dir exists;
  # be sure to remove it just in case 
  if (-d $tmpsadir) {
    rmdir( $tmpsadir ) or die "spamd: $tmpsadir not empty: $!";
  }
  if (-d $tmphome) {
    rmdir( $tmphome ) or die "spamd: $tmphome not empty: $!";
  }
  mkdir( $tmphome,  0700 ) or die "spamd: cannot create $tmphome: $!";
  mkdir( $tmpsadir, 0700 ) or die "spamd: cannot create $tmpsadir: $!";
  $ENV{HOME} = $tmphome;

  $spamtest->compile_now(0,1);  # ensure all modules etc. are loaded
  $/ = "\n";                    # argh, Razor resets this!  Bad Razor!

  # now clean up the stuff we just created, and make us taint-safe
  delete $ENV{HOME};

  # bug 2015, bug 2223: rmpath() is not taint safe, so we've got to implement
  # our own poor man's rmpath. If it fails, we report only the first error.
  my $err;
  foreach my $d ( ( $tmpsadir, $tmphome ) ) {
    opendir( TMPDIR, $d ) or $err ||= "open $d: $!";
    unless ($err) {
      foreach my $f ( File::Spec->no_upwards( readdir(TMPDIR) ) ) {
        $f =
          Mail::SpamAssassin::Util::untaint_file_path(
          File::Spec->catfile( $d, $f ) );
        unlink($f) or $err ||= "remove $f: $!";
      }
      closedir(TMPDIR) or $err ||= "close $d: $!";
    }
    rmdir($d) or $err ||= "remove $d: $!";
  }

  # If the dir still exists, log a warning.
  if ( -d $tmphome ) {
    $err ||= "do something: $!";
    warn "spamd: failed to remove $tmphome: could not $err\n";
  }
}

# Keep calling syswrite until the entire buffer is written out
# Retry if EAGAIN/EWOULDBLOCK or when partial buffer is written
# Limit the number of retries to keep the execution time bounded
sub syswrite_full_buffer {
  my ($sock, $buf, $numretries) = @_;
  $numretries ||= 10;       # default 10 retries
  my $length = length($buf);
  my $written = 0;
  my $try = 0;

  while (($try < $numretries) && ($length > $written)) {
      my $nbytes = syswrite($sock, $buf, $length - $written, $written);
      if (!defined $nbytes) {
	  unless ((exists &Errno::EAGAIN && $! == &Errno::EAGAIN)
		  || (exists &Errno::EWOULDBLOCK && $! == &Errno::EWOULDBLOCK))
	  {
	      # an error that wasn't non-blocking I/O-related.  that's serious
	      return undef;
	  }
	  # errcode says to try again
      }
      else {

	  if ($nbytes == 0) {
	      return $written;  # return early if no error but nothing was written
	  }

	  $written += $nbytes;
      }
      $try++;
  }

  return $written;      # it's complete, we can return
}

sub map_server_sockets {
  $fd_inet = $server_inet ? $server_inet->fileno : undef;
  $fd_unix = $server_unix ? $server_unix->fileno : undef;
  $fd_ssl  = $server_ssl  ? $server_ssl->fileno  : undef;

  $server_select_mask = '';
  $server_inet and vec($server_select_mask, $fd_inet, 1) = 1;
  $server_unix and vec($server_select_mask, $fd_unix, 1) = 1;
  $server_ssl  and vec($server_select_mask, $fd_ssl,  1) = 1;

  my $back_selector = $server_select_mask;
  $backchannel->set_selector(\$back_selector);

  # and set a boolean indicating whether or not we have > 1 server socket
  $have_multiple_server_socks =
      ((defined $fd_inet ? 1 : 0) +
      (defined $fd_unix ? 1 : 0) +
      (defined $fd_ssl  ? 1 : 0)) > 1;
}

__DATA__

=head1 NAME

spamd - daemonized version of spamassassin

=head1 SYNOPSIS

spamd [options]

Options:

 -l, --allow-tell                  Allow learning/reporting
 -c, --create-prefs                Create user preferences files
 -C path, --configpath=path        Path for default config files
 --siteconfigpath=path             Path for site configs
 --cf='config line'                Additional line of configuration
 -d, --daemonize                   Daemonize
 -h, --help                        Print usage message
 -i [ipaddr], --listen-ip=ipaddr   Listen on the IP ipaddr
 --ipv4only, --ipv4-only, --ipv4   Disable attempted use of ipv6 for DNS
 -p port, --port=port              Listen on specified port
 -m num, --max-children=num        Allow maximum num children
 --min-children=num                Allow minimum num children
 --min-spare=num                Lower limit for number of spare children
 --max-spare=num                Upper limit for number of spare children
 --max-conn-per-child=num	   Maximum connections accepted by child 
                                   before it is respawned
 --round-robin                     Use traditional prefork algorithm
 --timeout-tcp=secs                Connection timeout for client headers
 --timeout-child=secs              Connection timeout for message checks
 -q, --sql-config                  Enable SQL config (needs -x)
 -Q, --setuid-with-sql             Enable SQL config (needs -x,
                                   enables use of -H)
 --ldap-config                     Enable LDAP config (needs -x)
 --setuid-with-ldap                Enable LDAP config (needs -x,
                                   enables use of -H)
 --virtual-config-dir=dir          Enable pattern based Virtual configs
                                   (needs -x)
 -r pidfile, --pidfile             Write the process id to pidfile
 -s facility, --syslog=facility    Specify the syslog facility
 --syslog-socket=type              How to connect to syslogd
 -u username, --username=username  Run as username
 -g groupname, --groupname=groupname  Run as groupname
 -v, --vpopmail                    Enable vpopmail config
 -x, --nouser-config               Disable user config files
 --auth-ident                      Use ident to authenticate spamc user
 --ident-timeout=timeout           Timeout for ident connections
 -A host,..., --allowed-ips=..,..  Limit ip addresses which can connect
 -D, --debug[=areas]               Print debugging messages (for areas)
 -L, --local                       Use local tests only (no DNS)
 -P, --paranoid                    Die upon user errors
 -H [dir], --helper-home-dir[=dir]  Specify a different HOME directory
 --ssl                             Run an SSL server
 --ssl-port port                   Listen on port for SSL connections
 --ssl-version sslversion          Specify SSL protocol version to use
 --server-key keyfile              Specify an SSL keyfile
 --server-cert certfile            Specify an SSL certificate
 --socketpath=path                 Listen on given UNIX domain socket
 --socketowner=name                Set UNIX domain socket file's owner
 --socketgroup=name                Set UNIX domain socket file's group
 --socketmode=mode                 Set UNIX domain socket file's mode
 -V, --version                     Print version and exit

=head1 DESCRIPTION

The purpose of this program is to provide a daemonized version of the
spamassassin executable.  The goal is improving throughput performance for
automated mail checking.

This is intended to be used alongside C<spamc>, a fast, low-overhead C client
program.

See the README file in the C<spamd> directory of the SpamAssassin distribution
for more details.

Note: Although C<spamd> will check per-user config files for every message, any
changes to the system-wide config files will require either restarting spamd
or forcing it to reload itself via B<SIGHUP> for the changes to take effect.

Note: If C<spamd> receives a B<SIGHUP>, it internally reloads itself, which
means that it will change its pid and might not restart at all if its
environment changed  (ie. if it can't change back into its own directory).  If
you plan to use B<SIGHUP>, you should always start C<spamd> with the B<-r>
switch to know its current pid.

=head1 OPTIONS

Options of the long form can be shortened as long as they remain
unambiguous.  (i.e. B<--dae> can be used instead of B<--daemonize>)
Also, boolean options (like B<--user-config>) can be negated by
adding I<no> (B<--nouser-config>), however, this is usually unnecessary.

=over 4

=item B<-l>, B<--allow-tell>

Allow learning and forgetting (to a local Bayes database), reporting
and revoking (to a remote database) by spamd. The client issues a TELL
command to tell what type of message is being processed and whether
local (learn/forget) or remote (report/revoke) databases should be
updated.

Note that spamd always trusts the username passed in (unless
B<--auth-ident> is used) so clients could maliciously learn messages
for other users. (This is not ususally a concern with an SQL Bayes
store as users will typically have read-write access directly to the
database, and can also use C<sa-learn> with the B<-u> option to
achieve the same result.)

=item B<-c>, B<--create-prefs>

Create user preferences files if they don't exist (default: don't).

=item B<-C> I<path>, B<--configpath>=I<path>

Use the specified path for locating the distributed configuration files.
Ignore the default directories (usually C</usr/share/spamassassin> or similar).

=item B<--siteconfigpath>=I<path>

Use the specified path for locating site-specific configuration files.  Ignore
the default directories (usually C</etc/mail/spamassassin> or similar).

=item B<--cf='config line'>

Add additional lines of configuration directly from the command-line, parsed
after the configuration files are read.   Multiple B<--cf> arguments can be
used, and each will be considered a separate line of configuration.

=item B<-d>, B<--daemonize>

Detach from starting process and run in background (daemonize).

=item B<-h>, B<--help>

Print a brief help message, then exit without further action.

=item B<-V>, B<--version>

Print version information, then exit without further action.

=item B<-i> [I<ipaddress>], B<--listen-ip>[=I<ipaddress>], B<--ip-address>[=I<ipaddress>]

Tells spamd to listen on the specified IP address (defaults to 127.0.0.1).  If
you specify no IP address after the switch, spamd will listen on all interfaces.
(This is equal to the address 0.0.0.0).  You can also use a valid hostname which
will make spamd listen on the first address that name resolves to.

=item B<-p> I<port>, B<--port>=I<port>

Optionally specifies the port number for the server to listen on (default: 783).

If the B<--ssl> switch is used, and B<--ssl-port> is not supplied, then this
port will be used to accept SSL connections instead of unencrypted connections.
If the B<--ssl> switch is used, and B<--ssl-port> is set, then unencrypted
connections will be accepted on the B<--port> at the same time as encrypted
connections are accepted at B<--ssl-port>.


=item B<-q>, B<--sql-config>

Turn on SQL lookups even when per-user config files have been disabled
with B<-x>. this is useful for spamd hosts which don't have user's
home directories but do want to load user preferences from an SQL
database.

If your spamc client does not support sending the C<User:> header,
like C<exiscan>, then the SQL username used will always be B<nobody>.

=item B<--ldap-config>

Turn on LDAP lookups. This is completely analog to C<--sql-config>,
only it is using an LDAP server.

=item B<-Q>, B<--setuid-with-sql>

Turn on SQL lookups even when per-user config files have been disabled
with B<-x> and also setuid to the user.  This is useful for spamd hosts
which want to load user preferences from an SQL database but also wish to
support the use of B<-H> (Helper home directories.)

=item B<--setuid-with-ldap>

Turn on LDAP lookups even when per-user config files have been disabled
with B<-x> and also setuid to the user.  This is again completely analog
to C<--setuid-with-sql>, only it is using an LDAP server.

=item B<--virtual-config-dir>=I<pattern>

This option specifies where per-user preferences can be found for virtual
users, for the B<-x> switch. The I<pattern> is used as a base pattern for the
directory name.  Any of the following escapes can be used:

=over 4

=item %u -- replaced with the full name of the current user, as sent by spamc.

=item %l -- replaced with the 'local part' of the current username.  In other
words, if the username is an email address, this is the part before the C<@>
sign.

=item %d -- replaced with the 'domain' of the current username.  In other
words, if the username is an email address, this is the part after the C<@>
sign.

=item %% -- replaced with a single percent sign (%).

=back

So for example, if C</vhome/users/%u/spamassassin> is specified, and spamc
sends a virtual username of C<jm@example.com>, the directory
C</vhome/users/jm@example.com/spamassassin> will be used.

The set of characters allowed in the virtual username for this path are
restricted to:

	A-Z a-z 0-9 - + _ . , @ =

All others will be replaced by underscores (C<_>).

This path must be a writable directory.  It will be created if it does not
already exist.  If a file called B<user_prefs> exists in this directory (note:
B<not> in a C<.spamassassin> subdirectory!), it will be loaded as the user's
preferences.  The Bayes databases for that user will be stored in this directory.

Note that this B<requires> that B<-x> is used, and cannot be combined with
SQL- or LDAP-based configuration.

The pattern B<must> expand to an absolute directory when spamd is running
daemonized (B<-d>).

Currently, use of this without B<-u> is not supported. This inhibits setuid.

=item B<-r> I<pidfile>, B<--pidfile>=I<pidfile>

Write the process ID of the spamd parent to the file specified by I<pidfile>.
The file will be unlinked when the parent exits.  Note that when running
with the B<-u> option, the file must be writable by that user.

=item B<-v>, B<--vpopmail>

Enable vpopmail config.  If specified with with B<-u> set to the vpopmail user,
this allows spamd to lookup/create user_prefs in the vpopmail user's own
maildir.  This option is useful for vpopmail virtual users who do not have an
entry in the system /etc/passwd file.

Currently, use of this without B<-u> is not supported. This inhibits setuid.

=item B<-s> I<facility>, B<--syslog>=I<facility>

Specify the syslog facility to use (default: mail).  If C<stderr> is specified,
output will be written to stderr. (This is useful if you're running C<spamd>
under the C<daemontools> package.) With a I<facility> of C<file>, all output
goes to spamd.log. I<facility> is interpreted as a file name to log to if it
contains any characters except a-z and 0-9. C<null> disables logging completely
(used internally).

Examples:
	spamd -s mail                 # use syslog, facility mail (default)
	spamd -s ./mail               # log to file ./mail
	spamd -s stderr 2>/dev/null   # log to stderr, throw messages away
	spamd -s null                 # the same as above
	spamd -s file                 # log to file ./spamd.log
	spamd -s /var/log/spamd.log   # log to file /var/log/spamd.log

If logging to a file is enabled and that log file is rotated, the spamd server
must be restarted with a SIGHUP. (If the log file is just truncated, this is
not needed but still recommended.)

Note that logging to a file does not use locking, so you cannot intermix
logging from spamd and other processes into the same file.  If you want
to mix logging like this, use syslog instead.

If you use syslog logging, it is essential to send a SIGHUP to the spamd daemon
when you restart the syslogd daemon.  (This is due to a shortcoming in Perl's
syslog handling, where the disappearance of the connection to the syslogd is
considered a fatal error.)

=item B<--syslog-socket>=I<type>

Specify how spamd should send messages to syslogd.  The options are C<unix>,
C<inet> or C<none>.   The default is to try C<unix> first, falling back to
C<inet> if perl detects errors in its C<unix> support.

Some platforms, or versions of perl, are shipped with dysfunctional versions of
the B<Sys::Syslog> package which do not support some socket types, so you may
need to set this.  If you get error messages regarding B<__PATH_LOG> or similar
from spamd, try changing this setting.

The socket type C<file> is used internally and should not be specified.  Use
the C<-s> switch instead.

=item B<-u> I<username>, B<--username>=I<username>

Run as the named user.  If this option is not set, the default behaviour
is to setuid() to the user running C<spamc>, if C<spamd> is running
as root.

Note: "--username=root" is not a valid option.  If specified, C<spamd> will
exit with a fatal error on startup.

=item B<-g> I<groupname>, B<--groupname>=I<groupname>

Run as the named group if --username is being used. If this option is
not set when --username is used then the primary group for the user
given to --username is used.

=item B<-x>, B<--nouser-config>, B<--user-config>

Turn off(on) reading of per-user configuration files (user_prefs) from the
user's home directory.  The default behaviour is to read per-user
configuration from the user's home directory.

This option does not disable or otherwise influence the SQL, LDAP or
Virtual Config Dir settings.

=item B<--auth-ident>

Verify the username provided by spamc using ident.  This is only
useful if connections are only allowed from trusted hosts (because an
identd that lies is trivial to create) and if spamc REALLY SHOULD be
running as the user it represents.  Connections are terminated
immediately if authentication fails.  In this case, spamc will pass
the mail through unchecked.  Failure to connect to an ident server,
and response timeouts are considered authentication failures.  This
requires that Net::Ident be installed.

=item B<--ident-timeout>=I<timeout>

Wait at most I<timeout> seconds for a response to ident queries.
Authentication that takes long that I<timeout> seconds will fail, and
mail will not be processed.  Setting this to 0.0 or less results in no
timeout, which is STRONGLY discouraged.  The default is 5 seconds.

=item B<-A> I<host,...>, B<--allowed-ips>=I<host,...>

Specify a list of authorized hosts or networks which can connect to this spamd
instance. Single IP addresses can be given, ranges of IP addresses in
address/masklength CIDR format, or ranges of IP addresses by listing 3 or less
octets with a trailing dot.  Hostnames are not supported, only IP addresses.
This option can be specified multiple times, or can take a list of addresses
separated by commas.  Examples:

B<-A 10.11.12.13> -- only allow connections from C<10.11.12.13>.

B<-A 10.11.12.13,10.11.12.14> -- only allow connections from C<10.11.12.13> and
C<10.11.12.14>.

B<-A 10.200.300.0/24> -- allow connections from any machine in the range
C<10.200.300.*>.

B<-A 10.> -- allow connections from any machine in the range C<10.*.*.*>.

By default, connections are only accepted from localhost [127.0.0.1].

=item B<-D> [I<area,...>], B<--debug> [I<area,...>]

Produce debugging output. If no areas are listed, all debugging information is
printed. Diagnostic output can also be enabled for each area individually;
I<area> is the area of the code to instrument. For example, to produce
diagnostic output on bayes, learn, and dns, use:

        spamassassin -D bayes,learn,dns

Higher priority informational messages that are suitable for logging in normal
circumstances are available with an area of "info".

For more information about which areas (also known as channels) are available,
please see the documentation at:

	C<http://wiki.apache.org/spamassassin/DebugChannels>

=item B< --ipv4only>, B<--ipv4-only>, B<--ipv4>

Do not use IPv6 for DNS tests. Use if the existing tests
for IPv6 availablity produce incorrect results or crashes.

=item B<-L>, B<--local>

Perform only local tests on all mail.  In other words, skip DNS and other
network tests.  Works the same as the C<-L> flag to C<spamassassin(1)>.

=item B<-P>, B<--paranoid>

Die on user errors (for the user passed from spamc) instead of falling back to
user I<nobody> and using the default configuration.

=item B<-m> I<number> , B<--max-children>=I<number>

This option specifies the maximum number of children to spawn.
Spamd will spawn that number of children, then sleep in the background
until a child dies, wherein it will go and spawn a new child.

Incoming connections can still occur if all of the children are busy,
however those connections will be queued waiting for a free child.
The minimum value is C<1>, the default value is C<5>.

Please note that there is a OS specific maximum of connections that can be
queued (Try C<perl -MSocket -e'print SOMAXCONN'> to find this maximum).

Note that if you run too many servers for the amount of free RAM available, you
run the danger of hurting performance by causing a high swap load as server
processes are swapped in and out continually.

=item B<--min-children>=I<number>

The minimum number of children that will be kept running.  The minimum value is
C<1>, the default value is C<1>.  If you have lots of free RAM, you may want to
increase this.

=item B<--min-spare>=I<number>

The lower limit for the number of spare children allowed to run.  A
spare, or idle, child is one that is not handling a scan request.   If
there are too few spare children available, a new server will be started
every second or so.  The default value is C<1>.

=item B<--max-spare>=I<number>

The upper limit for the number of spare children allowed to run.  If there
are too many spare children, one will be killed every second or so until
the number of idle children is in the desired range.  The default value
is C<2>.

=item B<--max-conn-per-child>=I<number>

This option specifies the maximum number of connections each child
should process before dying and letting the master spamd process spawn
a new child.  The minimum value is C<1>, the default value is C<200>.

=item B<--round-robin>

By default, C<spamd> will attempt to keep a small number of "hot" child
processes as busy as possible, and keep any others as idle as possible, using
something similar to the Apache httpd server scaling algorithm.  This is
accomplished by the master process coordinating the activities of the children.
This switch will disable this scaling algorithm, and the behaviour seen in
the 3.0.x versions will be used instead, where all processes receive an
equal load and no scaling takes place.

=item B<--timeout-tcp>=I<number>

This option specifies the number of seconds to wait for headers from a
client (spamc) before closing the connection.  The minimum value is C<1>, 
the default value is C<30>, and a value of C<0> will disable socket
timeouts completely.

=item B<--timeout-child>=I<number>

This option specifies the number of seconds to wait for a spamd child to
to process or check a message.  The minimum value is C<1>, the default 
value is C<300>, and a value of C<0> will disable child timeouts completely.

=item B<-H> I<directory>, B<--helper-home-dir>=I<directory>

Specify that external programs such as Razor, DCC, and Pyzor should have
a HOME environment variable set to a specific directory.  The default
is to use the HOME environment variable setting from the shell running
spamd.  By specifying no argument, spamd will use the spamc caller's
home directory instead.

=item B<--ssl>

Accept only SSL connections on the associated port.
The B<IO::Socket::SSL> perl module must be installed.

If the B<--ssl> switch is used, and B<--ssl-port> is not supplied, then
B<--port> port will be used to accept SSL connections instead of unencrypted
connections.  If the B<--ssl> switch is used, and B<--ssl-port> is set, then
unencrypted connections will be accepted on the B<--port>, at the same time as
encrypted connections are accepted at B<--ssl-port>.

=item B<--ssl-port>=I<port>

Optionally specifies the port number for the server to listen on for
SSL connections (default: whatever --port uses).  See B<--ssl> for
more details.

=item B<--ssl-version>=I<sslversion>

Specify the SSL protocol version to use, one of
B<sslv2>, B<sslv3>, B<tlsv1>, or B<sslv23>.
The default, B<sslv23>, is the most flexible, accepting a SSLv2 or higher
hello handshake, then negotiating use of SSLv3 or TLSv1 protocol if the client
can accept it.
Specifying B<--ssl-version> implies B<--ssl>.

=item B<--server-key> I<keyfile>

Specify the SSL key file to use for SSL connections.

=item B<--server-cert> I<certfile>

Specify the SSL certificate file to use for SSL connections.

=item B<--socketpath> I<pathname>

Listen on UNIX domain path I<pathname> instead of a TCP socket.

Warning: the Perl support on BSD platforms for UNIX domain sockets seems to
have a bug regarding paths of over 100 bytes or so (SpamAssassin bug 4380).  If
you see a 'could not find newly-created UNIX socket' error message, and the
path appears truncated, this may be the cause.  Try using a shorter path
to the socket.

By default, use of B<--socketpath> will inhibit SSL connections and unencrypted
TCP connections.  To enable them, specify B<--port> and/or B<--ssl-port>
explicitly.

=item B<--socketowner> I<name>

Set UNIX domain socket to be owned by the user named I<name>.  Note
that this requires that spamd be started as C<root>, and if C<-u>
is used, that user should have write permissions to unlink the file
later, for when the C<spamd> server is killed.

=item B<--socketgroup> I<name>

Set UNIX domain socket to be owned by the group named I<name>.  See
C<--socketowner> for notes on ownership and permissions.

=item B<--socketmode> I<mode>

Set UNIX domain socket to use the octal mode I<mode>.  Note that if C<-u> is
used, that user should have write permissions to unlink the file later, for
when the C<spamd> server is killed.

=back

=head1 SEE ALSO

spamc(1)
spamassassin(1)
Mail::SpamAssassin::Conf(3)
Mail::SpamAssassin(3)

=head1 PREREQUISITES

C<Mail::SpamAssassin>

=head1 AUTHORS

The SpamAssassin(tm) Project (http://spamassassin.apache.org/)

=head1 LICENSE

SpamAssassin is distributed under the Apache License, Version 2.0, as
described in the file C<LICENSE> included with the distribution.

=cut
